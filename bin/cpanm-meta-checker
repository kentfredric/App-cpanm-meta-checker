
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/cpanm/meta/checker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANM_META_CHECKER';
  use 5.008;    # utf8
  use strict;
  use warnings;
  use utf8;
  
  package App::cpanm::meta::checker;
  
  # ABSTRACT: Verify and sanity check your installation verses cpanm metafiles
  
  # AUTHORITY
  
  =head1 SYNOPSIS
  
      cpanm-meta-checker --all --verbose
  
  =head1 DESCRIPTION
  
  C<cpanm> installs a few auxilary files:
  
      $SITELIB/.meta/DISTNAME-DISTVERSION/MYMETA.json
      $SITELIB/.meta/DISTNAME-DISTVERSION/install.json
  
  These files describe several things, such as dependencies
  declared by upstream, and sniffed extra context.
  
  This tool exists to read those files, and verify that their dependencies
  are still holding true, that no new conflicting dependencies have
  been installed and are silently sitting there broken.
  
  Also, as C<cpanm>'s auxilary files are really a prototype
  for what may eventually become a toolchain standard, this tool
  is also a prototype for a toolchain standard checker.
  
  =cut
  
  use Moo 1.000008;
  use Path::Tiny qw( path );
  
  has 'search_dirs' => (
      is      => 'ro',
      lazy    => 1,
      builder => sub {
          require Config;
          my @paths;
          push @paths,
            path( $Config::Config{sitelibexp} )
            ->child( $Config::Config{archname} )->child('.meta');
          return \@paths;
      },
  );
  
  sub all_search_dirs {
      return @{ $_[0]->search_dirs };
  }
  
  sub all_search_dir_child {
      my ( $self, @childpath ) = @_;
      my @answers = grep { -e $_ }
        map { path($_)->child(@childpath) } @{ $_[0]->search_dirs };
      return @answers unless $self->sorted;
      return ( my @sorted = sort @answers );
  }
  
  sub all_search_dir_children {
      my ($self) = @_;
      my @answers = map { path($_)->children } @{ $_[0]->search_dirs };
      return @answers unless $self->sorted;
      return ( my @sorted = sort @answers );
  }
  
  has 'tests' => (
      is      => ro =>,
      lazy    => 1,
      builder => sub {
          return [ 'list_empty', 'list_duplicates', ];
      },
  );
  
  has 'sorted' => (
      is      => ro  =>,
      lazy    => 1,
      builder => sub { return; }
  );
  
  has 'mode' => (
      is => ro =>,
      lazy => 1,
      builder => sub { return 'all' },
  );
  
  =method C<check_path>
  
      ->check_path('./foo/bar/baz');
  
  Read the content from C<./foo/bar/baz> and check its consistency.
  
  =cut
  
  sub check_path {
      my ( $self, $path ) = @_;
      require App::cpanm::meta::checker::State;
      my $state = App::cpanm::meta::checker::State->new( tests => $self->tests );
      return $state->check_path($path);
  }
  
  =method C<check_release>
  
      ->check_release('Moose-2.000000')
  
  Read the metadata for the exact release stated and perform checks on it.
  
  =cut
  
  sub check_release {
      my ( $self, $releasename ) = @_;
      require App::cpanm::meta::checker::State;
      my $state = App::cpanm::meta::checker::State->new( tests => $self->tests );
      for my $dir ( $self->all_search_dir_child($releasename) ) {
          $state->check_path($dir);
      }
      return;
  }
  
  =method C<check_distname>
  
      ->check_distname('Moose')
  
  Check metadata for any C<dist(s)> named C<Moose>
  
  Note: There may be directories residual from past installs.
  
  =cut
  
  sub check_distname {
      my ( $self, $distname ) = @_;
      require App::cpanm::meta::checker::State;
      my $state = App::cpanm::meta::checker::State->new( tests => $self->tests );
  
      for my $dir (
          grep { path($_)->basename =~ /\A\Q$distname\E-[^-]+(?:TRIAL)?\z/ }
          $self->all_search_dir_children )
      {
          $state->check_path($dir);
      }
      return;
  }
  
  =method C<check_all>
  
      ->check_all
  
  Check metadata for all installed dists.
  
  =cut
  
  sub check_all {
      my ($self) = @_;
      require App::cpanm::meta::checker::State;
      my $state = App::cpanm::meta::checker::State->new( tests => $self->tests );
      for my $dir ( $self->all_search_dir_children ) {
          $state->check_path($dir);
      }
      return;
  }
  
  
  sub run_command {
      my ( $self ) = @_;
      if ( $self->mode eq 'all' ) {
          return $self->check_all;
      }
      return;
  }
  sub new_from_command {
      my ( $class , %defaults ) = @_;
  
      my $config = {};
  
      require Getopt::Long;
      Getopt::Long::Configure('auto_version','auto_help');
  
      Getopt::Long::GetOptions(
          's|sort!' => \$config->{sort},
          'A|all!'  => sub { $config->{mode} = 'all' },
          'verbose!' => \$config->{verbose},
      );
  
      return $class->new( { %defaults, %{$config}} );
  }
  1;
APP_CPANM_META_CHECKER

$fatpacked{"App/cpanm/meta/checker/State.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANM_META_CHECKER_STATE';
  use 5.008;    # utf8
  use strict;
  use warnings;
  use utf8;
  
  package App::cpanm::meta::checker::State;
  
  # ABSTRACT: Shared state for a single test run
  
  # AUTHORITY
  
  use Moo qw(has);
  use Path::Tiny qw(path);
  
  has 'tests' => (
      is      => ro =>,
      lazy    => 1,
      builder => sub {
          return [ 'list_empty', 'list_duplicates', ];
      },
  );
  
  has 'list_fd' => (
      is      => ro =>,
      lazy    => 1,
      builder => sub {
          \*STDERR;
      }
  );
  
  has '_duplicates' => (
      is      => ro =>,
      lazy    => 1,
      builder => sub {
          require App::cpanm::meta::checker::State::Duplicates;
          return App::cpanm::meta::checker::State::Duplicates->new();
      },
  );
  
  sub x_test_list {
      my ( $self, $path, $state ) = @_;
      $self->list_fd->printf( "list:%s\n", path($path)->basename );
  }
  
  sub x_test_list_nonempty {
      my ( $self, $path, $state ) = @_;
      return unless path($path)->children;
      $self->list_fd->printf( "nonempty:%s\n", path($path)->basename );
  }
  
  sub x_test_list_empty {
      my ( $self, $path, $state ) = @_;
      return if path($path)->children;
      $self->list_fd->printf( "empty:%s\n", path($path)->basename );
  }
  
  sub x_test_list_duplicates {
      my ( $self, $path, $state ) = @_;
      my $basename = path($path)->basename;
      my ( $dist, $version ) = $basename =~ /\A(.*)-([^-]+(?:-TRIAL)?)\z/;
  
      $self->_duplicates->seen_dist_version( $dist, $version );
  
      return unless $self->_duplicates->has_duplicates($dist);
  
      my $fmt = "duplicate:%s-%s\n";
  
      if ( $self->_duplicates->reported_duplicates($dist) ) {
          printf $fmt, $dist, $version;
          return;
      }
  
      $self->list_fd->printf( $fmt, $dist, $_ )
        for $self->_duplicates->duplicate_versions($dist);
  
      $self->_duplicates->reported_duplicates( $dist, 1 );
  
      return;
  }
  
  =method C<check_path>
  
      ->check_path('./foo/bar/baz');
  
  Read the content from C<./foo/bar/baz> and check its consistency.
  
  =cut
  
  sub check_path {
      my ( $self, $path ) = @_;
      my $state = {};
      for my $test ( @{ $self->tests } ) {
          my $method = 'x_test_' . $test;
          if ( not $self->can($method) ) {
              die "no method $method for test $test";
          }
          $self->$method( $path, $state );
      }
  }
  
  no Moo;
  
  1;
  
APP_CPANM_META_CHECKER_STATE

$fatpacked{"App/cpanm/meta/checker/State/Duplicates.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANM_META_CHECKER_STATE_DUPLICATES';
  use 5.008;    # utf8
  use strict;
  use warnings;
  use utf8;
  
  package App::cpanm::meta::checker::State::Duplicates;
  
  # ABSTRACT: Data tracking for duplicate distribution metadata
  
  # AUTHORITY
  
  use Moo;
  
  has 'dists' => (
      is      => ro  =>,
      lazy    => 1,
      builder => sub { {} },
  );
  
  sub seen_dist_version {
      my ( $self, $dist, $version ) = @_;
      if ( not exists $self->dists->{$dist} ) {
          $self->dists->{$dist} =
            App::cpanm::meta::checker::State::Duplicate::Dist->new();
      }
      $self->dists->{$dist}->seen_version($version);
  }
  
  sub has_duplicates {
      my ( $self, $dist ) = @_;
      return unless exists $self->dists->{$dist};
      return $self->dists->{$dist}->has_duplicates;
  }
  
  sub reported_duplicates {
      my ( $self, $dist, $set ) = @_;
      return unless exists $self->dists->{$dist};
      return $self->dists->{$dist}->reported($set) if @_ > 2;
      return $self->dists->{$dist}->reported();
  }
  
  sub duplicate_versions {
      my ( $self, $dist ) = @_;
      return unless exists $self->dists->{$dist};
      return $self->dists->{$dist}->duplicate_versions;
  }
  
  no Moo;
  
  package    ## hide
    App::cpanm::meta::checker::State::Duplicate::Dist;
  
  use Moo;
  
  has 'reported' => (
      is      => rw  =>,
      lazy    => 1,
      builder => sub { return; },
  );
  
  has 'versions' => (
      is   => ro =>,
      lazy => 1,
      builder => sub { return {} },
  );
  
  sub has_duplicates {
      my ($self) = @_;
      return ( keys %{ $self->versions } > 1 );
  }
  
  sub seen_version {
      my ( $self, $version ) = @_;
      $self->versions->{$version} = 1;
  }
  
  sub duplicate_versions {
      my ($self) = @_;
      return keys %{ $self->versions };
  }
  
  1;
  
APP_CPANM_META_CHECKER_STATE_DUPLICATES

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!perl

# Bash Invocation guard
eval "echo This script requires Perl";
exit 1
  if 0;

use strict;
use warnings;

use App::cpanm::meta::checker;
my $app = App::cpanm::meta::checker->new_from_command;
$app->run_command();
exit 0;

