#!perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/cpanm/meta/checker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANM_META_CHECKER';
  use 5.008;use strict;use warnings;use utf8;package App::cpanm::meta::checker;$App::cpanm::meta::checker::VERSION='0.001000';our$AUTHORITY='cpan:KENTNL';use Moo 1.000008 qw(has);use Path::Tiny qw(path);use App::cpanm::meta::checker::State;use Config qw();use Getopt::Long;has 'search_dirs'=>(is=>'ro',lazy=>1,builder=>sub {my@paths;push@paths,path($Config::Config{sitelibexp})->child($Config::Config{archname})->child('.meta');return \@paths},);sub all_search_dirs {return @{$_[0]->search_dirs}}sub all_search_dir_child {my ($self,@childpath)=@_;my@answers=grep {-e $_}map {path($_)->child(@childpath)}@{$_[0]->search_dirs};return@answers unless$self->sorted;return (my@sorted=sort@answers)}sub all_search_dir_children {my ($self)=@_;my@answers=map {path($_)->children}@{$_[0]->search_dirs};return@answers unless$self->sorted;return (my@sorted=sort@answers)}has 'tests'=>(is=>ro=>,lazy=>1,builder=>sub {return ['list_empty','list_duplicates',]},);has 'sorted'=>(is=>ro=>,lazy=>1,builder=>sub {return});has 'mode'=>(is=>ro=>,lazy=>1,builder=>sub {return 'all'},);sub check_path {my ($self,$path)=@_;my$state=App::cpanm::meta::checker::State->new(tests=>$self->tests);return$state->check_path($path)}sub check_release {my ($self,$releasename)=@_;my$state=App::cpanm::meta::checker::State->new(tests=>$self->tests);for my$dir ($self->all_search_dir_child($releasename)){$state->check_path($dir)}return}sub check_distname {my ($self,$distname)=@_;my$state=App::cpanm::meta::checker::State->new(tests=>$self->tests);for my$dir (grep {path($_)->basename =~ /\A\Q$distname\E-[^-]+(?:TRIAL)?\z/}$self->all_search_dir_children){$state->check_path($dir)}return}sub check_all {my ($self)=@_;my$state=App::cpanm::meta::checker::State->new(tests=>$self->tests);for my$dir ($self->all_search_dir_children){$state->check_path($dir)}return}sub run_command {my ($self)=@_;if ($self->mode eq 'all'){return$self->check_all}return}sub new_from_command {my ($class,%defaults)=@_;my$config={};Getopt::Long::Configure('auto_version','auto_help');Getopt::Long::GetOptions('s|sort!'=>\$config->{sort},'A|all!'=>sub {$config->{mode}='all'},'verbose!'=>\$config->{verbose},);return$class->new({%defaults,%{$config}})}1;
APP_CPANM_META_CHECKER

$fatpacked{"App/cpanm/meta/checker/State.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANM_META_CHECKER_STATE';
  use 5.008;use strict;use warnings;use utf8;package App::cpanm::meta::checker::State;$App::cpanm::meta::checker::State::VERSION='0.001000';our$AUTHORITY='cpan:KENTNL';use Moo qw(has);use App::cpanm::meta::checker::State::Duplicates;use Path::Tiny qw(path);has 'tests'=>(is=>ro=>,lazy=>1,builder=>sub {return ['list_empty','list_duplicates',]},);has 'list_fd'=>(is=>ro=>,lazy=>1,builder=>sub {\*STDERR});has '_duplicates'=>(is=>ro=>,lazy=>1,builder=>sub {return App::cpanm::meta::checker::State::Duplicates->new()},);sub x_test_list {my ($self,$path,$state)=@_;$self->list_fd->printf("list:%s\n",path($path)->basename)}sub x_test_list_nonempty {my ($self,$path,$state)=@_;return unless path($path)->children;$self->list_fd->printf("nonempty:%s\n",path($path)->basename)}sub x_test_list_empty {my ($self,$path,$state)=@_;return if path($path)->children;$self->list_fd->printf("empty:%s\n",path($path)->basename)}sub x_test_list_duplicates {my ($self,$path,$state)=@_;my$basename=path($path)->basename;my ($dist,$version)=$basename =~ /\A(.*)-([^-]+(?:-TRIAL)?)\z/;$self->_duplicates->seen_dist_version($dist,$version);return unless$self->_duplicates->has_duplicates($dist);my$fmt="duplicate:%s-%s\n";if ($self->_duplicates->reported_duplicates($dist)){printf$fmt,$dist,$version;return}$self->list_fd->printf($fmt,$dist,$_)for$self->_duplicates->duplicate_versions($dist);$self->_duplicates->reported_duplicates($dist,1);return}sub check_path {my ($self,$path)=@_;my$state={};for my$test (@{$self->tests}){my$method='x_test_' .$test;if (not $self->can($method)){die "no method $method for test $test"}$self->$method($path,$state)}}no Moo;1;
APP_CPANM_META_CHECKER_STATE

$fatpacked{"App/cpanm/meta/checker/State/Duplicates.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANM_META_CHECKER_STATE_DUPLICATES';
  use 5.008;use strict;use warnings;use utf8;package App::cpanm::meta::checker::State::Duplicates;$App::cpanm::meta::checker::State::Duplicates::VERSION='0.001000';our$AUTHORITY='cpan:KENTNL';use Moo;has 'dists'=>(is=>ro=>,lazy=>1,builder=>sub {{}},);sub seen_dist_version {my ($self,$dist,$version)=@_;if (not exists$self->dists->{$dist}){$self->dists->{$dist}=App::cpanm::meta::checker::State::Duplicate::Dist->new()}$self->dists->{$dist}->seen_version($version)}sub has_duplicates {my ($self,$dist)=@_;return unless exists$self->dists->{$dist};return$self->dists->{$dist}->has_duplicates}sub reported_duplicates {my ($self,$dist,$set)=@_;return unless exists$self->dists->{$dist};return$self->dists->{$dist}->reported($set)if @_ > 2;return$self->dists->{$dist}->reported()}sub duplicate_versions {my ($self,$dist)=@_;return unless exists$self->dists->{$dist};return$self->dists->{$dist}->duplicate_versions}no Moo;package App::cpanm::meta::checker::State::Duplicate::Dist;use Moo;has 'reported'=>(is=>rw=>,lazy=>1,builder=>sub {return},);has 'versions'=>(is=>ro=>,lazy=>1,builder=>sub {return {}},);sub has_duplicates {my ($self)=@_;return (keys %{$self->versions}> 1)}sub seen_version {my ($self,$version)=@_;$self->versions->{$version}=1}sub duplicate_versions {my ($self)=@_;return keys %{$self->versions}}1;
APP_CPANM_META_CHECKER_STATE_DUPLICATES

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;use strict;use warnings;our$VERSION='0.12';use Sub::Exporter::Progressive -setup=>{exports=>[qw(in_global_destruction) ],groups=>{default=>[-all ]},};if (defined ${^GLOBAL_PHASE}){eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1' or die $@}elsif (eval {require Devel::GlobalDestruction::XS;no warnings 'once';*in_global_destruction=\&Devel::GlobalDestruction::XS::in_global_destruction;1}){}else {require B;eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1' or die $@}1;
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Import/Into.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IMPORT_INTO';
  package Import::Into;use strict;use warnings FATAL=>'all';our$VERSION='1.002001';sub _prelude {my$target=shift;my ($package,$file,$line,$level)=ref$target ? @{$target}{qw(package filename line)}: $target =~ /[^0-9]/ ? ($target): (undef,undef,undef,$target);if (defined$level){my ($p,$fn,$ln)=caller($level + 2);$package ||=$p;$file ||=$fn;$line ||=$ln}qq{package $package;\n} .($file ? "#line $line \"$file\"\n" : '')}sub _make_action {my ($action,$target)=@_;my$version=ref$target && $target->{version};my$ver_check=$version ? '$_[0]->VERSION($version);' : '';eval _prelude($target).qq{sub { $ver_check shift->$action(\@_) }} or die "Failed to build action sub to ${action} for ${target}: $@"}sub import::into {my ($class,$target,@args)=@_;_make_action(import=>$target)->($class,@args)}sub unimport::out_of {my ($class,$target,@args)=@_;_make_action(unimport=>$target)->($class,@args)}1;
IMPORT_INTO

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;use strictures 1;use Moo::_Utils;use base qw(Moo::Object);use Sub::Quote;use B 'perlstring';use Scalar::Util 'blessed';use overload ();use Module::Runtime qw(use_module);BEGIN {our$CAN_HAZ_XS=!$ENV{MOO_XS_DISABLE}&& _maybe_load_module('Class::XSAccessor')&& (eval {Class::XSAccessor->VERSION('1.07')});our$CAN_HAZ_XS_PRED=$CAN_HAZ_XS && (eval {Class::XSAccessor->VERSION('1.17')})}sub _SIGDIE {our ($CurrentAttribute,$OrigSigDie);my$sigdie=$OrigSigDie && $OrigSigDie!=\&_SIGDIE ? $OrigSigDie : sub {die $_[0]};return$sigdie->(@_)if ref($_[0]);my$attr_desc=_attr_desc(@$CurrentAttribute{qw(name init_arg)});$sigdie->("$CurrentAttribute->{step} for $attr_desc failed: $_[0]")}sub _die_overwrite {my ($pkg,$method,$type)=@_;die "You cannot overwrite a locally defined method ($method) with @{[ $type || 'an accessor' ]}"}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$spec->{allow_overwrite}++ if$name =~ s/^\+//;die "Must have an is" unless my$is=$spec->{is};if ($is eq 'ro'){$spec->{reader}=$name unless exists$spec->{reader}}elsif ($is eq 'rw'){$spec->{accessor}=$name unless exists$spec->{accessor}or ($spec->{reader}and $spec->{writer})}elsif ($is eq 'lazy'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{lazy}=1;$spec->{builder}||='_build_'.$name unless$spec->{default}}elsif ($is eq 'rwp'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{writer}="_set_${name}" unless exists$spec->{writer}}elsif ($is ne 'bare'){die "Unknown is ${is}"}if (exists$spec->{builder}){if(ref$spec->{builder}){$self->_validate_codulatable('builder',$spec->{builder},"$into->$name",'or a method name');$spec->{builder_sub}=$spec->{builder};$spec->{builder}=1}$spec->{builder}='_build_'.$name if ($spec->{builder}||0)eq 1;die "Invalid builder for $into->$name - not a valid method name" if$spec->{builder}!~ /\A[A-Za-z_][A-Za-z0-9_]*(?:::[A-Za-z_][A-Za-z0-9_]*)*\z/}if (($spec->{predicate}||0)eq 1){$spec->{predicate}=$name =~ /^_/ ? "_has${name}" : "has_${name}"}if (($spec->{clearer}||0)eq 1){$spec->{clearer}=$name =~ /^_/ ? "_clear${name}" : "clear_${name}"}if (($spec->{trigger}||0)eq 1){$spec->{trigger}=quote_sub('shift->_trigger_'.$name.'(@_)')}for my$setting (qw(isa coerce)){next if!exists$spec->{$setting};$self->_validate_codulatable($setting,$spec->{$setting},"$into->$name")}if (exists$spec->{default}){if (!defined$spec->{default}|| ref$spec->{default}){$self->_validate_codulatable('default',$spec->{default},"$into->$name",'or a non-ref')}}if (exists$spec->{moosify}){if (ref$spec->{moosify}ne 'ARRAY'){$spec->{moosify}=[$spec->{moosify}]}for my$spec (@{$spec->{moosify}}){$self->_validate_codulatable('moosify',$spec,"$into->$name")}}my%methods;if (my$reader=$spec->{reader}){_die_overwrite($into,$reader,'a reader')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${reader}")}{CODE};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)){$methods{$reader}=$self->_generate_xs(getters=>$into,$reader,$name,$spec)}else {$self->{captures}={};$methods{$reader}=quote_sub "${into}::${reader}" =>'    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n" .$self->_generate_get($name,$spec)=>delete$self->{captures}}}if (my$accessor=$spec->{accessor}){_die_overwrite($into,$accessor,'an accessor')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${accessor}")}{CODE};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)&& $self->is_simple_set($name,$spec)){$methods{$accessor}=$self->_generate_xs(accessors=>$into,$accessor,$name,$spec)}else {$self->{captures}={};$methods{$accessor}=quote_sub "${into}::${accessor}" =>$self->_generate_getset($name,$spec)=>delete$self->{captures}}}if (my$writer=$spec->{writer}){_die_overwrite($into,$writer,'a writer')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${writer}")}{CODE};if (our$CAN_HAZ_XS && $self->is_simple_set($name,$spec)){$methods{$writer}=$self->_generate_xs(setters=>$into,$writer,$name,$spec)}else {$self->{captures}={};$methods{$writer}=quote_sub "${into}::${writer}" =>$self->_generate_set($name,$spec)=>delete$self->{captures}}}if (my$pred=$spec->{predicate}){_die_overwrite($into,$pred,'a predicate')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${pred}")}{CODE};if (our$CAN_HAZ_XS && our$CAN_HAZ_XS_PRED){$methods{$pred}=$self->_generate_xs(exists_predicates=>$into,$pred,$name,$spec)}else {$methods{$pred}=quote_sub "${into}::${pred}"=>'    '.$self->_generate_simple_has('$_[0]',$name,$spec)."\n" }}if (my$pred=$spec->{builder_sub}){_install_coderef("${into}::$spec->{builder}"=>$spec->{builder_sub})}if (my$cl=$spec->{clearer}){_die_overwrite($into,$cl,'a clearer')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${cl}")}{CODE};$methods{$cl}=quote_sub "${into}::${cl}"=>$self->_generate_simple_clear('$_[0]',$name,$spec)."\n" }if (my$hspec=$spec->{handles}){my$asserter=$spec->{asserter}||='_assert_'.$name;my@specs=do {if (ref($hspec)eq 'ARRAY'){map [$_=>$_ ],@$hspec}elsif (ref($hspec)eq 'HASH'){map [$_=>ref($hspec->{$_})? @{$hspec->{$_}}: $hspec->{$_}],keys %$hspec}elsif (!ref($hspec)){map [$_=>$_ ],use_module('Moo::Role')->methods_provided_by(use_module($hspec))}else {die "You gave me a handles of ${hspec} and I have no idea why"}};for my$delegation_spec (@specs){my ($proxy,$target,@args)=@$delegation_spec;_die_overwrite($into,$proxy,'a delegation')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${proxy}")}{CODE};$self->{captures}={};$methods{$proxy}=quote_sub "${into}::${proxy}"=>$self->_generate_delegation($asserter,$target,\@args),delete$self->{captures}}}if (my$asserter=$spec->{asserter}){$self->{captures}={};$methods{$asserter}=quote_sub "${into}::${asserter}"=>$self->_generate_asserter($name,$spec),delete$self->{captures}}\%methods}sub is_simple_attribute {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(lazy default builder coerce isa trigger predicate weak_ref)}sub is_simple_get {my ($self,$name,$spec)=@_;!($spec->{lazy}and ($spec->{default}or $spec->{builder}))}sub is_simple_set {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(coerce isa trigger weak_ref)}sub has_eager_default {my ($self,$name,$spec)=@_;(!$spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub _generate_get {my ($self,$name,$spec)=@_;my$simple=$self->_generate_simple_get('$_[0]',$name,$spec);if ($self->is_simple_get($name,$spec)){$simple}else {$self->_generate_use_default('$_[0]',$name,$spec,$self->_generate_simple_has('$_[0]',$name,$spec),)}}sub generate_simple_has {my$self=shift;$self->{captures}={};my$code=$self->_generate_simple_has(@_);($code,delete$self->{captures})}sub _generate_simple_has {my ($self,$me,$name)=@_;"exists ${me}->{${\perlstring $name}}"}sub _generate_simple_clear {my ($self,$me,$name)=@_;"    delete ${me}->{${\perlstring $name}}\n"}sub generate_get_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_get_default(@_);($code,delete$self->{captures})}sub generate_use_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_use_default(@_);($code,delete$self->{captures})}sub _generate_use_default {my ($self,$me,$name,$spec,$test)=@_;my$get_value=$self->_generate_get_default($me,$name,$spec);if ($spec->{coerce}){$get_value=$self->_generate_coerce($name,$get_value,$spec->{coerce})}$test." ? \n" .$self->_generate_simple_get($me,$name,$spec)."\n:" .($spec->{isa}? "    do {\n      my \$value = ".$get_value.";\n" ."      ".$self->_generate_isa_check($name,'$value',$spec->{isa}).";\n" ."      ".$self->_generate_simple_set($me,$name,$spec,'$value')."\n" ."    }\n" : '    ('.$self->_generate_simple_set($me,$name,$spec,$get_value).")\n")}sub _generate_get_default {my ($self,$me,$name,$spec)=@_;if (exists$spec->{default}){ref$spec->{default}? $self->_generate_call_code($name,'default',$me,$spec->{default}): perlstring$spec->{default}}else {"${me}->${\$spec->{builder}}"}}sub generate_simple_get {my ($self,@args)=@_;$self->_generate_simple_get(@args)}sub _generate_simple_get {my ($self,$me,$name)=@_;my$name_str=perlstring$name;"${me}->{${name_str}}"}sub _generate_set {my ($self,$name,$spec)=@_;if ($self->is_simple_set($name,$spec)){$self->_generate_simple_set('$_[0]',$name,$spec,'$_[1]')}else {my ($coerce,$trigger,$isa_check)=@{$spec}{qw(coerce trigger isa)};my$value_store='$_[0]';my$code;if ($coerce){$value_store='$value';$code="do { my (\$self, \$value) = \@_;\n" ."        \$value = " .$self->_generate_coerce($name,$value_store,$coerce).";\n"}else {$code="do { my \$self = shift;\n"}if ($isa_check){$code .= "        ".$self->_generate_isa_check($name,$value_store,$isa_check).";\n"}my$simple=$self->_generate_simple_set('$self',$name,$spec,$value_store);if ($trigger){my$fire=$self->_generate_trigger($name,'$self',$value_store,$trigger);$code .= "        ".$simple.";\n        ".$fire.";\n" ."        $value_store;\n"}else {$code .= "        ".$simple.";\n"}$code .= "      }";$code}}sub generate_coerce {my$self=shift;$self->{captures}={};my$code=$self->_generate_coerce(@_);($code,delete$self->{captures})}sub _attr_desc {my ($name,$init_arg)=@_;return perlstring($name)if!defined($init_arg)or $init_arg eq $name;return perlstring($name).' (constructor argument: '.perlstring($init_arg).')'}sub _generate_coerce {my ($self,$name,$value,$coerce,$init_arg)=@_;$self->_generate_die_prefix($name,"coercion",$init_arg,$self->_generate_call_code($name,'coerce',"${value}",$coerce))}sub generate_trigger {my$self=shift;$self->{captures}={};my$code=$self->_generate_trigger(@_);($code,delete$self->{captures})}sub _generate_trigger {my ($self,$name,$obj,$value,$trigger)=@_;$self->_generate_call_code($name,'trigger',"${obj}, ${value}",$trigger)}sub generate_isa_check {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_isa_check(@args);($code,delete$self->{captures})}sub _generate_die_prefix {my ($self,$name,$prefix,$arg,$inside)=@_;"do {\n" .'  local $Method::Generate::Accessor::CurrentAttribute = {' .'    init_arg => '.(defined$arg ? B::perlstring($arg): 'undef').",\n" .'    name     => '.B::perlstring($name).",\n" .'    step     => '.B::perlstring($prefix).",\n" ."  };\n" .'  local $Method::Generate::Accessor::OrigSigDie = $SIG{__DIE__};'."\n" .'  local $SIG{__DIE__} = \&Method::Generate::Accessor::_SIGDIE;'."\n" .$inside ."}\n"}sub _generate_isa_check {my ($self,$name,$value,$check,$init_arg)=@_;$self->_generate_die_prefix($name,"isa check",$init_arg,$self->_generate_call_code($name,'isa_check',$value,$check))}sub _generate_call_code {my ($self,$name,$type,$values,$sub)=@_;$sub=\&{$sub}if blessed($sub);if (my$quoted=quoted_from_sub($sub)){my$local=1;if ($values eq '@_' || $values eq '$_[0]'){$local=0;$values='@_'}my$code=$quoted->[1];if (my$captures=$quoted->[2]){my$cap_name=qq{\$${type}_captures_for_}.$self->_sanitize_name($name);$self->{captures}->{$cap_name}=\$captures;Sub::Quote::inlinify($code,$values,Sub::Quote::capture_unroll($cap_name,$captures,6),$local)}else {Sub::Quote::inlinify($code,$values,undef,$local)}}else {my$cap_name=qq{\$${type}_for_}.$self->_sanitize_name($name);$self->{captures}->{$cap_name}=\$sub;"${cap_name}->(${values})"}}sub _sanitize_name {my ($self,$name)=@_;$name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;$name}sub generate_populate_set {my$self=shift;$self->{captures}={};my$code=$self->_generate_populate_set(@_);($code,delete$self->{captures})}sub _generate_populate_set {my ($self,$me,$name,$spec,$source,$test,$init_arg)=@_;if ($self->has_eager_default($name,$spec)){my$get_indent=' ' x ($spec->{isa}? 6 : 4);my$get_default=$self->_generate_get_default('$new',$name,$spec);my$get_value=defined($spec->{init_arg})? "(\n${get_indent}  ${test}\n${get_indent}   ? ${source}\n${get_indent}   : " .$get_default ."\n${get_indent})" : $get_default;if ($spec->{coerce}){$get_value=$self->_generate_coerce($name,$get_value,$spec->{coerce},$init_arg)}($spec->{isa}? "    {\n      my \$value = ".$get_value.";\n      " .$self->_generate_isa_check($name,'$value',$spec->{isa},$init_arg).";\n" .'      '.$self->_generate_simple_set($me,$name,$spec,'$value').";\n" ."    }\n" : '    '.$self->_generate_simple_set($me,$name,$spec,$get_value).";\n").($spec->{trigger}? '    ' .$self->_generate_trigger($name,$me,$self->_generate_simple_get($me,$name,$spec),$spec->{trigger})." if ${test};\n" : '')}else {"    if (${test}) {\n" .($spec->{coerce}? "      $source = " .$self->_generate_coerce($name,$source,$spec->{coerce},$init_arg).";\n" : "").($spec->{isa}? "      " .$self->_generate_isa_check($name,$source,$spec->{isa},$init_arg).";\n" : "")."      ".$self->_generate_simple_set($me,$name,$spec,$source).";\n" .($spec->{trigger}? "      " .$self->_generate_trigger($name,$me,$self->_generate_simple_get($me,$name,$spec),$spec->{trigger}).";\n" : "")."    }\n"}}sub _generate_core_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=perlstring$name;"${me}->{${name_str}} = ${value}"}sub _generate_simple_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=perlstring$name;my$simple=$self->_generate_core_set($me,$name,$spec,$value);if ($spec->{weak_ref}){require Scalar::Util;my$get=$self->_generate_simple_get($me,$name,$spec);my$weak_simple="do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }";Moo::_Utils::lt_5_8_3()? <<"EOC" : $weak_simple}else {$simple}}sub _generate_getset {my ($self,$name,$spec)=@_;q{(@_ > 1}."\n      ? ".$self->_generate_set($name,$spec)."\n      : ".$self->_generate_get($name,$spec)."\n    )"}sub _generate_asserter {my ($self,$name,$spec)=@_;"do {\n" ."  my \$val = ".$self->_generate_get($name,$spec).";\n" ."  unless (".$self->_generate_simple_has('$_[0]',$name,$spec).") {\n" .qq!    die "Attempted to access '${name}' but it is not set";\n! ."  }\n" ."  \$val;\n" ."}\n"}sub _generate_delegation {my ($self,$asserter,$target,$args)=@_;my$arg_string=do {if (@$args){$self->{captures}{'@curries'}=$args;'@curries, @_'}else {'@_'}};"shift->${asserter}->${target}(${arg_string});"}sub _generate_xs {my ($self,$type,$into,$name,$slot)=@_;Class::XSAccessor->import(class=>$into,$type=>{$name=>$slot },replace=>1,);$into->can($name)}sub default_construction_string {'{}'}sub _validate_codulatable {my ($self,$setting,$value,$into,$appended)=@_;my$invalid="Invalid $setting '" .overload::StrVal($value)."' for $into not a coderef";$invalid .= " $appended" if$appended;unless (ref$value and (ref$value eq 'CODE' or blessed($value))){die "$invalid or code-convertible object"}unless (eval {\&$value}){die "$invalid and could not be converted to a coderef: $@"}1}1;
        eval { Scalar::Util::weaken($simple); 1 }
          ? do { no warnings 'void'; $get }
          : do {
            if( \$@ =~ /Modification of a read-only value attempted/) {
              require Carp;
              Carp::croak( sprintf (
                'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                $name_str,
              ) );
            } else {
              die \$@;
            }
          }
  EOC
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;use strictures 1;use base qw(Moo::Object);use Sub::Quote;use Moo::_Utils;use B 'perlstring';sub generate_method {my ($self,$into)=@_;quote_sub "${into}::BUILDALL",join '',$self->_handle_subbuild($into),qq{    my \$self = shift;\n},$self->buildall_body_for($into,'$self','@_'),qq{    return \$self\n}}sub _handle_subbuild {my ($self,$into)=@_;'    if (ref($_[0]) ne '.perlstring($into).') {'."\n".'      return shift->Moo::Object::BUILDALL(@_)'.";\n".'    }'."\n"}sub buildall_body_for {my ($self,$into,$me,$args)=@_;my@builds=grep *{_getglob($_)}{CODE},map "${_}::BUILD",reverse @{Moo::_Utils::_get_linear_isa($into)};join '',map qq{    ${me}->${_}(${args});\n},@builds}1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;use strictures 1;use Sub::Quote;use base qw(Moo::Object);use Sub::Defer;use B 'perlstring';use Moo::_Utils qw(_getstash);sub register_attribute_specs {my ($self,@new_specs)=@_;my$specs=$self->{attribute_specs}||={};while (my ($name,$new_spec)=splice@new_specs,0,2){if ($name =~ s/^\+//){die "has '+${name}' given but no ${name} attribute already exists" unless my$old_spec=$specs->{$name};for my$key (keys %$old_spec){if (!exists$new_spec->{$key}){$new_spec->{$key}=$old_spec->{$key}unless$key eq 'handles'}elsif ($key eq 'moosify'){$new_spec->{$key}=[map {ref $_ eq 'ARRAY' ? @$_ : $_}($old_spec->{$key},$new_spec->{$key})]}}}if (exists$new_spec->{init_arg}&&!defined$new_spec->{init_arg}&& $new_spec->{required}){die "${name} attribute can't be required with init_arg => undef"}$new_spec->{index}=scalar keys %$specs unless defined$new_spec->{index};$specs->{$name}=$new_spec}$self}sub all_attribute_specs {$_[0]->{attribute_specs}}sub accessor_generator {$_[0]->{accessor_generator}}sub construction_string {my ($self)=@_;$self->{construction_string}||=$self->_build_construction_string}sub buildall_generator {require Method::Generate::BuildAll;Method::Generate::BuildAll->new}sub _build_construction_string {my ($self)=@_;my$builder=$self->{construction_builder};$builder ? $self->$builder : 'bless(' .$self->accessor_generator->default_construction_string .', $class);'}sub install_delayed {my ($self)=@_;my$package=$self->{package};defer_sub "${package}::new"=>sub {unquote_sub$self->generate_method($package,'new',$self->{attribute_specs},{no_install=>1 })};$self}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;for my$no_init (grep!exists($spec->{$_}{init_arg}),keys %$spec){$spec->{$no_init}{init_arg}=$no_init}local$self->{captures}={};my$body='    my $class = shift;'."\n" .'    $class = ref($class) if ref($class);'."\n";$body .= $self->_handle_subconstructor($into,$name);my$into_buildargs=$into->can('BUILDARGS');if ($into_buildargs && $into_buildargs!=\&Moo::Object::BUILDARGS){$body .= $self->_generate_args_via_buildargs}else {$body .= $self->_generate_args}$body .= $self->_check_required($spec);$body .= '    my $new = '.$self->construction_string.";\n";$body .= $self->_assign_new($spec);if ($into->can('BUILD')){$body .= $self->buildall_generator->buildall_body_for($into,'$new','$args')}$body .= '    return $new;'."\n";if ($into->can('DEMOLISH')){require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new->generate_method($into)}quote_sub "${into}::${name}"=>$body,$self->{captures},$quote_opts||{}}sub _handle_subconstructor {my ($self,$into,$name)=@_;if (my$gen=$self->{subconstructor_handler}){'    if ($class ne '.perlstring($into).') {'."\n".$gen.'    }'."\n"}else {''}}sub _cap_call {my ($self,$code,$captures)=@_;@{$self->{captures}}{keys %$captures}=values %$captures if$captures;$code}sub _generate_args_via_buildargs {my ($self)=@_;q{    my $args = $class->BUILDARGS(@_);}."\n" .q{    die "BUILDARGS did not return a hashref" unless ref($args) eq 'HASH';} ."\n"}sub _generate_args {my ($self)=@_;return <<'_EOA'}sub _assign_new {my ($self,$spec)=@_;my$ag=$self->accessor_generator;my%test;NAME: foreach my$name (sort keys %$spec){my$attr_spec=$spec->{$name};next NAME unless defined($attr_spec->{init_arg})or $ag->has_eager_default($name,$attr_spec);$test{$name}=$attr_spec->{init_arg}}join '',map {my$arg_key=perlstring($test{$_});my$test="exists \$args->{$arg_key}";my$source="\$args->{$arg_key}";my$attr_spec=$spec->{$_};$self->_cap_call($ag->generate_populate_set('$new',$_,$attr_spec,$source,$test,$test{$_},))}sort keys%test}sub _check_required {my ($self,$spec)=@_;my@required_init=map$spec->{$_}{init_arg},grep {my%s=%{$spec->{$_}};$s{required}and not($s{builder}or $s{default})}sort keys %$spec;return '' unless@required_init;'    if (my @missing = grep !exists $args->{$_}, qw(' .join(' ',@required_init).')) {'."\n" .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n" ."    }\n"}use Moo;Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(attribute_specs=>{is=>'ro',reader=>'all_attribute_specs',},accessor_generator=>{is=>'ro' },construction_string=>{is=>'lazy' },construction_builder=>{is=>'lazy' },subconstructor_handler=>{is=>'ro' },package=>{is=>'ro' },);1;
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;use strictures 1;use base qw(Moo::Object);use Sub::Quote;use Moo::_Utils;use B qw(perlstring);sub generate_method {my ($self,$into)=@_;quote_sub "${into}::DEMOLISHALL",join '',$self->_handle_subdemolish($into),qq{    my \$self = shift;\n},$self->demolishall_body_for($into,'$self','@_'),qq{    return \$self\n};quote_sub "${into}::DESTROY",join '',q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Moo::_Utils;
        eval {
          $self->DEMOLISHALL(Moo::_Utils::_in_global_destruction);
        };
        $@;
      };
    
      no warnings 'misc';
      die $e if $e; # rethrow
    !}sub demolishall_body_for {my ($self,$into,$me,$args)=@_;my@demolishers=grep *{_getglob($_)}{CODE},map "${_}::DEMOLISH",@{Moo::_Utils::_get_linear_isa($into)};join '',map qq{    ${me}->${_}(${args});\n},@demolishers}sub _handle_subdemolish {my ($self,$into)=@_;'    if (ref($_[0]) ne '.perlstring($into).') {'."\n".'      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".'    }'."\n"}1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Method/Inliner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_INLINER';
  package Method::Inliner;use strictures 1;use Text::Balanced qw(extract_bracketed);use Sub::Quote ();sub slurp {do {local (@ARGV,$/)=$_[0];<>}}sub splat {open my$out,'>',$_[1]or die "can't open $_[1]: $!";print$out $_[0]or die "couldn't write to $_[1]: $!"}sub inlinify {my$file=$_[0];my@chunks=split /(^sub.*?^}$)/sm,slurp$file;warn join "\n--\n",@chunks;my%code;for my$chunk (@chunks){if (my ($name,$body)=$chunk =~ /^sub (\S+) {\n(.*)\n}$/s){$code{$name}=$body}}for my$chunk (@chunks){my ($me)=$chunk =~ /^sub.*{\n  my \((\$\w+).*\) = \@_;\n/ or next;my$meq=quotemeta$me;my$copy=$chunk;my ($fixed,$rest);while ($copy =~ s/^(.*?)${meq}->(\S+)(?=\()//s){my ($front,$name)=($1,$2);((my$body),$rest)=extract_bracketed($copy,'()');warn "spotted ${name} - ${body}";if ($code{$name}){warn "replacing";s/^\(//,s/\)$// for$body;$body="${me}, ".$body;$fixed .= $front.Sub::Quote::inlinify($code{$name},$body)}else {$fixed .= $front.$me.'->'.$name.$body}$copy=$rest}$fixed .= $rest if$fixed;warn$fixed if$fixed;$chunk=$fixed if$fixed}print join '',@chunks}1;
METHOD_INLINER

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  package Module::Runtime;BEGIN {require 5.006}BEGIN {${^WARNING_BITS}=""}our$VERSION="0.014";our@EXPORT_OK=qw($module_name_rx is_module_name is_valid_module_name check_module_name module_notional_filename require_module use_module use_package_optimistically $top_module_spec_rx $sub_module_spec_rx is_module_spec is_valid_module_spec check_module_spec compose_module_name);my%export_ok=map {($_=>undef)}@EXPORT_OK;sub import {my$me=shift;my$callpkg=caller(0);my$errs="";for(@_){if(exists$export_ok{$_}){if(/\A\$(.*)\z/s){*{$callpkg."::".$1}=\$$1}else {*{$callpkg."::".$_}=\&$_}}else {$errs .= "\"$_\" is not exported by the $me module\n"}}if($errs ne ""){die "${errs}Can't continue after import errors "."at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n"}}sub _is_string($) {my($arg)=@_;return defined($arg)&& ref(\$arg)eq "SCALAR"}our$module_name_rx=qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;my$qual_module_spec_rx=qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;my$unqual_top_module_spec_rx=qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$top_module_spec_rx=qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;my$unqual_sub_module_spec_rx=qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$sub_module_spec_rx=qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;sub is_module_name($) {_is_string($_[0])&& $_[0]=~ /\A$module_name_rx\z/o}*is_valid_module_name=\&is_module_name;sub check_module_name($) {unless(&is_module_name){die +(_is_string($_[0])? "`$_[0]'" : "argument")." is not a module name\n"}}sub module_notional_filename($) {&check_module_name;my($name)=@_;$name =~ s!::!/!g;return$name.".pm"}BEGIN {*_WORK_AROUND_HINT_LEAKAGE="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0}}BEGIN {if(_WORK_AROUND_BROKEN_MODULE_STATE){eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  };die $@ if $@ ne ""}}sub require_module($) {local %^H if _WORK_AROUND_HINT_LEAKAGE;if(_WORK_AROUND_BROKEN_MODULE_STATE){my$notional_filename=&module_notional_filename;my$guard=bless([$notional_filename ],"Module::Runtime::__GUARD__");my$result=CORE::require($notional_filename);pop @$guard;return$result}else {return scalar(CORE::require(&module_notional_filename))}}sub use_module($;$) {my($name,$version)=@_;require_module($name);$name->VERSION($version)if @_ >= 2;return$name}sub use_package_optimistically($;$) {my($name,$version)=@_;my$fn=module_notional_filename($name);eval {local$SIG{__DIE__};require_module($name)};die $@ if $@ ne "" && ($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s || $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);$name->VERSION($version)if @_ >= 2;return$name}sub is_module_spec($$) {my($prefix,$spec)=@_;return _is_string($spec)&& $spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o : qr/\A$top_module_spec_rx\z/o)}*is_valid_module_spec=\&is_module_spec;sub check_module_spec($$) {unless(&is_module_spec){die +(_is_string($_[1])? "`$_[1]'" : "argument")." is not a module specification\n"}}sub compose_module_name($$) {my($prefix,$spec)=@_;check_module_name($prefix)if defined$prefix;&check_module_spec;if($spec =~ s#\A(?:/|::)##){}else {$spec=$prefix."::".$spec if defined$prefix}$spec =~ s#/#::#g;return$spec}1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;use strictures 1;use Moo::_Utils;use B 'perlstring';use Sub::Defer ();use Import::Into;our$VERSION='1.004002';$VERSION=eval$VERSION;require Moo::sification;our%MAKERS;sub _install_tracked {my ($target,$name,$code)=@_;$MAKERS{$target}{exports}{$name}=$code;_install_coderef "${target}::${name}"=>"Moo::${name}"=>$code}sub import {my$target=caller;my$class=shift;_set_loaded(caller);strictures->import::into(1);if ($Role::Tiny::INFO{$target}and $Role::Tiny::INFO{$target}{is_role}){die "Cannot import Moo into a role"}$MAKERS{$target}||={};_install_tracked$target=>extends=>sub {$class->_set_superclasses($target,@_);$class->_maybe_reset_handlemoose($target);return};_install_tracked$target=>with=>sub {require Moo::Role;Moo::Role->apply_roles_to_package($target,@_);$class->_maybe_reset_handlemoose($target)};_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){require Carp;Carp::croak("Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_)}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;$class->_constructor_maker_for($target)->register_attribute_specs($name,$spec_ref);$class->_accessor_maker_for($target)->generate_method($target,$name,$spec_ref);$class->_maybe_reset_handlemoose($target)}return};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {require Class::Method::Modifiers;_install_modifier($target,$type,@_);return}}return if$MAKERS{$target}{is_class};my$stash=_getstash($target);my@not_methods=map {*$_{CODE}||()}grep!ref($_),values %$stash;@{$MAKERS{$target}{not_methods}={}}{@not_methods}=@not_methods;$MAKERS{$target}{is_class}=1;{no strict 'refs';@{"${target}::ISA"}=do {require Moo::Object;('Moo::Object')}unless @{"${target}::ISA"}}if ($INC{'Moo/HandleMoose.pm'}){Moo::HandleMoose::inject_fake_metaclass_for($target)}}sub unimport {my$target=caller;_unimport_coderefs($target,$MAKERS{$target})}sub _set_superclasses {my$class=shift;my$target=shift;for my$superclass (@_){_load_module($superclass);if ($INC{"Role/Tiny.pm"}&& $Role::Tiny::INFO{$superclass}){require Carp;Carp::croak("Can't extend role '$superclass'")}}@{*{_getglob("${target}::ISA")}{ARRAY}}=@_;if (my$old=delete$Moo::MAKERS{$target}{constructor}){delete _getstash($target)->{new};Moo->_constructor_maker_for($target)->register_attribute_specs(%{$old->all_attribute_specs})}elsif (!$target->isa('Moo::Object')){Moo->_constructor_maker_for($target)}no warnings 'once';$Moo::HandleMoose::MOUSE{$target}=[grep defined,map Mouse::Util::find_meta($_),@_ ]if Mouse::Util->can('find_meta')}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{"Moo/HandleMoose.pm"}){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub _accessor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{accessor}||=do {my$maker_class=do {if (my$m=do {if (my$defer_target=(Sub::Defer::defer_info($target->can('new'))||[])->[0]){my ($pkg)=($defer_target =~ /^(.*)::[^:]+$/);$MAKERS{$pkg}&& $MAKERS{$pkg}{accessor}}else {undef}}){ref($m)}else {require Method::Generate::Accessor;'Method::Generate::Accessor'}};$maker_class->new}}sub _constructor_maker_for {my ($class,$target,$select_super)=@_;return unless$MAKERS{$target};$MAKERS{$target}{constructor}||=do {require Method::Generate::Constructor;require Sub::Defer;my ($moo_constructor,$con);if ($select_super && $MAKERS{$select_super}){$moo_constructor=1;$con=$MAKERS{$select_super}{constructor}}else {my$t_new=$target->can('new');if ($t_new){if ($t_new==Moo::Object->can('new')){$moo_constructor=1}elsif (my$defer_target=(Sub::Defer::defer_info($t_new)||[])->[0]){my ($pkg)=($defer_target =~ /^(.*)::[^:]+$/);if ($MAKERS{$pkg}){$moo_constructor=1;$con=$MAKERS{$pkg}{constructor}}}}else {$moo_constructor=1}}($con ? ref($con): 'Method::Generate::Constructor')->new(package=>$target,accessor_generator=>$class->_accessor_maker_for($target),$moo_constructor ? ($con ? (construction_string=>$con->construction_string): ()): (construction_builder=>sub {'$class->'.$target.'::SUPER::new(' .($target->can('FOREIGNBUILDARGS')? '$class->FOREIGNBUILDARGS(@_)' : '@_').')'},),subconstructor_handler=>('      if ($Moo::MAKERS{$class}) {'."\n" .'        '.$class.'->_constructor_maker_for($class,'.perlstring($target).');'."\n" .'        return $class->new(@_)'.";\n" .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n" .'        return $meta->new_object($class->BUILDARGS(@_));'."\n" .'      }'."\n"),)->install_delayed ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})}}sub _concrete_methods_of {my ($me,$role)=@_;my$makers=$MAKERS{$role};my$stash=_getstash($role);my$not_methods={reverse %{$makers->{not_methods}||{}}};+{map {my$code=*{$stash->{$_}}{CODE};(!$code or exists$not_methods->{$code})? (): ($_=>$code)}grep!ref($stash->{$_}),keys %$stash }}1;
MOO

$fatpacked{"Moo/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_CONFLICTS';
  package Moo::Conflicts;use strict;use warnings;use Dist::CheckConflicts -dist=>'Moo',-conflicts=>{'HTML::Restrict'=>'2.1.5',},-also=>[qw(Carp Class::Method::Modifiers strictures Module::Runtime Role::Tiny Devel::GlobalDestruction) ],;1;
MOO_CONFLICTS

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;use strictures 1;use Moo::_Utils;use B qw(perlstring);our%TYPE_MAP;our$SETUP_DONE;sub import {return if$SETUP_DONE;inject_all();$SETUP_DONE=1}sub inject_all {require Class::MOP;inject_fake_metaclass_for($_)for grep $_ ne 'Moo::Object',do {no warnings 'once';keys%Moo::MAKERS};inject_fake_metaclass_for($_)for keys%Moo::Role::INFO;require Moose::Meta::Method::Constructor;@Moo::HandleMoose::FakeConstructor::ISA='Moose::Meta::Method::Constructor'}sub maybe_reinject_fake_metaclass_for {my ($name)=@_;our%DID_INJECT;if (delete$DID_INJECT{$name}){unless ($Moo::Role::INFO{$name}){Moo->_constructor_maker_for($name)->install_delayed}inject_fake_metaclass_for($name)}}sub inject_fake_metaclass_for {my ($name)=@_;require Class::MOP;require Moo::HandleMoose::FakeMetaClass;Class::MOP::store_metaclass_by_name($name,bless({name=>$name },'Moo::HandleMoose::FakeMetaClass'));require Moose::Util::TypeConstraints;if ($Moo::Role::INFO{$name}){Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name)}else {Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name)}}{package Moo::HandleMoose::FakeConstructor;sub _uninlined_body {\&Moose::Object::new}}sub inject_real_metaclass_for {my ($name)=@_;our%DID_INJECT;return Class::MOP::get_metaclass_by_name($name)if$DID_INJECT{$name};require Moose;require Moo;require Moo::Role;require Scalar::Util;Class::MOP::remove_metaclass_by_name($name);my ($am_role,$meta,$attr_specs,$attr_order)=do {if (my$info=$Moo::Role::INFO{$name}){my@attr_info=@{$info->{attributes}||[]};(1,Moose::Meta::Role->initialize($name),{@attr_info },[@attr_info[grep!($_ % 2),0..$#attr_info]])}elsif (my$cmaker=Moo->_constructor_maker_for($name)){my$specs=$cmaker->all_attribute_specs;(0,Moose::Meta::Class->initialize($name),$specs,[sort {$specs->{$a}{index}<=> $specs->{$b}{index}}keys %$specs ])}else {(0,Moose::Meta::Class->initialize($name),{},[])}};for my$spec (values %$attr_specs){if (my$inflators=delete$spec->{moosify}){$_->($spec)for @$inflators}}my%methods =%{($am_role ? 'Role::Tiny' : 'Moo')->_concrete_methods_of($name)};if (my$info=$Role::Tiny::INFO{$name}){delete$info->{methods}}Sub::Defer::undefer_sub($_)for grep defined,values%methods;my@attrs;{local @{_getstash($name)}{keys%methods};my%seen_name;for my$name (@$attr_order){$seen_name{$name}=1;my%spec=%{$attr_specs->{$name}};my%spec_map=(map {$_->name=>$_->init_arg||$_->name}((grep {$_->has_init_arg}$meta->attribute_metaclass->meta->get_all_attributes),grep {exists($_->{init_arg})? defined($_->init_arg): 1}map {my$meta=Moose::Util::resolve_metatrait_alias('Attribute',$_)->meta;map$meta->get_attribute($_),$meta->get_attribute_list}@{$spec{traits}||[]}));$spec_map{traits}||='traits';$spec{is}='ro' if$spec{is}eq 'lazy' or $spec{is}eq 'rwp';my$coerce=$spec{coerce};if (my$isa=$spec{isa}){my$tc=$spec{isa}=do {if (my$mapped=$TYPE_MAP{$isa}){my$type=$mapped->();Scalar::Util::blessed($type)&& $type->isa("Moose::Meta::TypeConstraint")or die "error inflating attribute '$name' for package '$_[0]': \$TYPE_MAP{$isa} did not return a valid type constraint'";$coerce ? $type->create_child_type(name=>$type->name): $type}else {Moose::Meta::TypeConstraint->new(constraint=>sub {eval {&$isa;1}})}};if ($coerce){$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{coerce}=1}}elsif ($coerce){my$attr=perlstring($name);my$tc=Moose::Meta::TypeConstraint->new(constraint=>sub {die "This is not going to work"},inlined=>sub {'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'},);$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{isa}=$tc;$spec{coerce}=1}%spec=map {$spec_map{$_}=>$spec{$_}}grep {exists$spec_map{$_}}keys%spec;push@attrs,$meta->add_attribute($name=>%spec)}for my$mouse (do {our%MOUSE;@{$MOUSE{$name}||[]}}){for my$attr ($mouse->get_all_attributes){my%spec=%{$attr};delete@spec{qw(associated_class associated_methods __METACLASS__ provides curries)};my$name=delete$spec{name};next if$seen_name{$name}++;push@attrs,$meta->add_attribute($name=>%spec)}}}for my$meth_name (keys%methods){my$meth_code=$methods{$meth_name};$meta->add_method($meth_name,$meth_code)if$meth_code}if ($am_role){my$info=$Moo::Role::INFO{$name};$meta->add_required_methods(@{$info->{requires}});for my$modifier (@{$info->{modifiers}}){my ($type,@args)=@$modifier;my$code=pop@args;$meta->${\"add_${type}_method_modifier"}($_,$code)for@args}}else {for my$attr (@attrs){for my$method (@{$attr->associated_methods}){$method->{body}=$name->can($method->name)}}bless($meta->find_method_by_name('new'),'Moo::HandleMoose::FakeConstructor',);require Method::Generate::DemolishAll}$meta->add_role(Class::MOP::class_of($_))for grep!/\|/ && $_ ne $name,do {no warnings 'once';keys %{$Role::Tiny::APPLIED_TO{$name}}};$DID_INJECT{$name}=1;$meta}1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;sub DESTROY {}sub AUTOLOAD {my ($meth)=(our$AUTOLOAD =~ /([^:]+)$/);require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->$meth(@_)}sub can {require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->can(@_)}sub isa {require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->isa(@_)}sub make_immutable {$_[0]}1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;use strictures 1;package Moo::HandleMoose;our%TYPE_MAP;package Moo::HandleMoose::_TypeMap;use Scalar::Util ();our%WEAK_TYPES;sub _str_to_ref {my$in=shift;return$in if ref$in;if ($in =~ /(?:^|=)[A-Z]+\(0x([0-9a-zA-Z]+)\)$/){my$id=do {no warnings 'portable';hex "$1"};require B;my$sv=bless \$id,'B::SV';my$ref=eval {$sv->object_2svref};if (!defined$ref){die <<'END_ERROR'}return$ref}return$in}sub TIEHASH {bless {},$_[0]}sub STORE {my ($self,$key,$value)=@_;my$type=_str_to_ref($key);$WEAK_TYPES{$type}=$type;Scalar::Util::weaken($WEAK_TYPES{$type})if ref$type;$self->{$key}=$value}sub FETCH {$_[0]->{$_[1]}}sub FIRSTKEY {my$a=scalar keys %{$_[0]};each %{$_[0]}}sub NEXTKEY {each %{$_[0]}}sub EXISTS {exists $_[0]->{$_[1]}}sub DELETE {delete $_[0]->{$_[1]}}sub CLEAR {%{$_[0]}=()}sub SCALAR {scalar %{$_[0]}}sub CLONE {my@types=map {defined$WEAK_TYPES{$_}? ($WEAK_TYPES{$_}=>$TYPE_MAP{$_}): ()}keys%TYPE_MAP;%WEAK_TYPES=();%TYPE_MAP=@types}sub DESTROY {my%types=%{$_[0]};untie%TYPE_MAP;%TYPE_MAP=%types}my@types=%TYPE_MAP;tie%TYPE_MAP,__PACKAGE__;%TYPE_MAP=@types;1;
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;use strictures 1;our%NO_BUILD;our%NO_DEMOLISH;our$BUILD_MAKER;our$DEMOLISH_MAKER;sub new {my$class=shift;unless (exists$NO_DEMOLISH{$class}){unless ($NO_DEMOLISH{$class}=!$class->can('DEMOLISH')){($DEMOLISH_MAKER ||=do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method($class)}}$NO_BUILD{$class}and return bless({ref($_[0])eq 'HASH' ? %{$_[0]}: @_},$class);$NO_BUILD{$class}=!$class->can('BUILD')unless exists$NO_BUILD{$class};$NO_BUILD{$class}? bless({ref($_[0])eq 'HASH' ? %{$_[0]}: @_},$class): do {my$proto=ref($_[0])eq 'HASH' ? $_[0]: {@_};bless({%$proto},$class)->BUILDALL($proto)}}sub BUILDARGS {my$class=shift;if (scalar @_==1){unless (defined $_[0]&& ref $_[0]eq 'HASH'){die "Single parameters to new() must be a HASH ref" ." data => ".$_[0]."\n"}return {%{$_[0]}}}elsif (@_ % 2){die "The new() method for $class expects a hash reference or a key/value list." ." You passed an odd number of arguments\n"}else {return {@_}}}sub BUILDALL {my$self=shift;$self->${\(($BUILD_MAKER ||=do {require Method::Generate::BuildAll;Method::Generate::BuildAll->new})->generate_method(ref($self)))}(@_)}sub DEMOLISHALL {my$self=shift;$self->${\(($DEMOLISH_MAKER ||=do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method(ref($self)))}(@_)}sub does {require Role::Tiny;{no warnings 'redefine';*does=\&Role::Tiny::does_role}goto&Role::Tiny::does_role}sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;use strictures 1;use Moo::_Utils;use Role::Tiny ();use base qw(Role::Tiny);use Import::Into;our$VERSION='1.004002';$VERSION=eval$VERSION;require Moo::sification;BEGIN {*INFO=\%Role::Tiny::INFO}our%INFO;our%APPLY_DEFAULTS;sub _install_tracked {my ($target,$name,$code)=@_;$INFO{$target}{exports}{$name}=$code;_install_coderef "${target}::${name}"=>"Moo::Role::${name}"=>$code}sub import {my$target=caller;my ($me)=@_;_set_loaded(caller);strictures->import::into(1);if ($Moo::MAKERS{$target}and $Moo::MAKERS{$target}{is_class}){die "Cannot import Moo::Role into a Moo class"}$INFO{$target}||={};my$stash=_getstash($target);_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){require Carp;Carp::croak("Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_)}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;($INFO{$target}{accessor_maker}||=do {require Method::Generate::Accessor;Method::Generate::Accessor->new})->generate_method($target,$name,$spec_ref);push @{$INFO{$target}{attributes}||=[]},$name,$spec_ref;$me->_maybe_reset_handlemoose($target)}};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {require Class::Method::Modifiers;push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];$me->_maybe_reset_handlemoose($target)}}_install_tracked$target=>requires=>sub {push @{$INFO{$target}{requires}||=[]},@_;$me->_maybe_reset_handlemoose($target)};_install_tracked$target=>with=>sub {$me->apply_roles_to_package($target,@_);$me->_maybe_reset_handlemoose($target)};return if$INFO{$target}{is_role};$INFO{$target}{is_role}=1;*{_getglob("${target}::meta")}=$me->can('meta');my@not_methods=('',map {*$_{CODE}||()}grep!ref($_),values %$stash);@{$INFO{$target}{not_methods}={}}{@not_methods}=@not_methods;$Role::Tiny::APPLIED_TO{$target}={$target=>undef };if ($INC{'Moo/HandleMoose.pm'}){Moo::HandleMoose::inject_fake_metaclass_for($target)}}sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}sub unimport {my$target=caller;_unimport_coderefs($target,$INFO{$target})}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{"Moo/HandleMoose.pm"}){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub methods_provided_by {my ($self,$role)=@_;$self->_inhale_if_moose($role);die "${role} is not a Moo::Role" unless$INFO{$role};return$self->SUPER::methods_provided_by($role)}sub _inhale_if_moose {my ($self,$role)=@_;_load_module($role);my$meta;if (!$INFO{$role}and ($INC{"Moose.pm"}and $meta=Class::MOP::class_of($role)and $meta->isa('Moose::Meta::Role'))or (Mouse::Util->can('find_meta')and $meta=Mouse::Util::find_meta($role)and $meta->isa('Mouse::Meta::Role'))){my$is_mouse=$meta->isa('Mouse::Meta::Role');$INFO{$role}{methods}={map +($_=>$role->can($_)),grep$role->can($_),grep!($is_mouse && $_ eq 'meta'),grep!$meta->get_method($_)->isa('Class::MOP::Method::Meta'),$meta->get_method_list };$Role::Tiny::APPLIED_TO{$role}={map +($_->name=>1),$meta->calculate_all_roles };$INFO{$role}{requires}=[$meta->get_required_method_list ];$INFO{$role}{attributes}=[map +($_=>do {my$attr=$meta->get_attribute($_);my$spec={%{$is_mouse ? $attr : $attr->original_options}};if ($spec->{isa}){my$get_constraint=do {my$pkg=$is_mouse ? 'Mouse::Util::TypeConstraints' : 'Moose::Util::TypeConstraints';_load_module($pkg);$pkg->can('find_or_create_isa_type_constraint')};my$tc=$get_constraint->($spec->{isa});my$check=$tc->_compiled_type_constraint;$spec->{isa}=sub {&$check or die "Type constraint failed for $_[0]"};if ($spec->{coerce}){$spec->{coerce}=$tc->${\($tc->can('coercion')||sub {$_[0]})}->_compiled_type_coercion}}$spec}),$meta->get_attribute_list ];my$mods=$INFO{$role}{modifiers}=[];for my$type (qw(before after around)){my$map=$meta->${\($meta->can("get_${type}_method_modifiers_map")or sub {shift->{"${type}_method_modifiers"}})};for my$method (keys %$map){for my$mod (@{$map->{$method}}){push @$mods,[$type=>$method=>$mod ]}}}require Class::Method::Modifiers if @$mods;$INFO{$role}{inhaled_from_moose}=1;$INFO{$role}{is_role}=1}}sub _maybe_make_accessors {my ($self,$target,$role)=@_;my$m;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}or $INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($target)and ref($m)ne 'Method::Generate::Accessor'){$self->_make_accessors($target,$role)}}sub _make_accessors_if_moose {my ($self,$target,$role)=@_;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}){$self->_make_accessors($target,$role)}}sub _make_accessors {my ($self,$target,$role)=@_;my$acc_gen=($Moo::MAKERS{$target}{accessor}||=do {require Method::Generate::Accessor;Method::Generate::Accessor->new});my$con_gen=$Moo::MAKERS{$target}{constructor};my@attrs=@{$INFO{$role}{attributes}||[]};while (my ($name,$spec)=splice@attrs,0,2){if ($con_gen){$spec=$con_gen->all_attribute_specs->{$name}}$acc_gen->generate_method($target,$name,$spec)}}sub role_application_steps {qw(_handle_constructor _maybe_make_accessors),$_[0]->SUPER::role_application_steps}sub apply_roles_to_package {my ($me,$to,@roles)=@_;for my$role (@roles){$me->_inhale_if_moose($role);die "${role} is not a Moo::Role" unless$INFO{$role}}$me->SUPER::apply_roles_to_package($to,@roles)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;$me->_inhale_if_moose($role);die "${role} is not a Moo::Role" unless$INFO{$role};$me->SUPER::apply_single_role_to_package($to,$role)}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$Role::Tiny::COMPOSED{class}{$new_name};for my$role (@roles){$me->_inhale_if_moose($role)}my$m;if ($INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($superclass)and ref($m)ne 'Method::Generate::Accessor'){*{_getglob("${new_name}::ISA")}=[$superclass ];$me->apply_roles_to_package($new_name,@roles);_set_loaded($new_name,(caller)[1]);return$new_name}require Sub::Quote;$me->SUPER::create_class_with_roles($superclass,@roles);for my$role (@roles){die "${role} is not a Role::Tiny" unless$INFO{$role}}$Moo::MAKERS{$new_name}={is_class=>1};$me->_handle_constructor($new_name,$_)for@roles;_set_loaded($new_name,(caller)[1]);return$new_name}sub apply_roles_to_object {my ($me,$object,@roles)=@_;my$new=$me->SUPER::apply_roles_to_object($object,@roles);_set_loaded(ref$new,(caller)[1]);my$apply_defaults=$APPLY_DEFAULTS{ref$new}||=do {my%attrs=map {@{$INFO{$_}{attributes}||[]}}@roles;if ($INC{'Moo.pm'}and keys%attrs and my$con_gen=Moo->_constructor_maker_for(ref$new)and my$m=Moo->_accessor_maker_for(ref$new)){require Sub::Quote;my$specs=$con_gen->all_attribute_specs;my$assign='';my%captures;for my$name (keys%attrs){my$spec=$specs->{$name};if ($m->has_eager_default($name,$spec)){my ($has,$has_cap)=$m->generate_simple_has('$_[0]',$name,$spec);my ($code,$pop_cap)=$m->generate_use_default('$_[0]',$name,$spec,$has);$assign .= $code;@captures{keys %$has_cap,keys %$pop_cap}=(values %$has_cap,values %$pop_cap)}}Sub::Quote::quote_sub($assign,\%captures)}else {sub {}}};$new->$apply_defaults;return$new}sub _composable_package_for {my ($self,$role)=@_;my$composed_name='Role::Tiny::_COMPOSABLE::'.$role;return$composed_name if$Role::Tiny::COMPOSED{role}{$composed_name};$self->_make_accessors_if_moose($composed_name,$role);$self->SUPER::_composable_package_for($role)}sub _install_single_modifier {my ($me,@args)=@_;_install_modifier(@args)}sub _handle_constructor {my ($me,$to,$role)=@_;my$attr_info=$INFO{$role}&& $INFO{$role}{attributes};return unless$attr_info && @$attr_info;if ($INFO{$to}){push @{$INFO{$to}{attributes}||=[]},@$attr_info}else {if ($INC{"Moo.pm"}and my$con=Moo->_constructor_maker_for($to)){$con->register_attribute_specs(map ref()? {%$_}: $_,@$attr_info)}}}1;
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;no warnings 'once';sub _getglob {\*{$_[0]}}sub _getstash {\%{"$_[0]::"}}use constant lt_5_8_3=>($] < 5.008003 or $ENV{MOO_TEST_PRE_583})? 1 : 0;use constant can_haz_subname=>eval {require Sub::Name};use strictures 1;use Module::Runtime qw(use_package_optimistically module_notional_filename);use Devel::GlobalDestruction ();use base qw(Exporter);use Moo::_mro;use Config;our@EXPORT=qw(_getglob _install_modifier _load_module _maybe_load_module _get_linear_isa _getstash _install_coderef _name_coderef _unimport_coderefs _in_global_destruction _set_loaded);sub _in_global_destruction ();*_in_global_destruction=\&Devel::GlobalDestruction::in_global_destruction;sub _install_modifier {my ($into,$type,$name,$code)=@_;if (my$to_modify=$into->can($name)){require Sub::Defer;Sub::Defer::undefer_sub($to_modify)}Class::Method::Modifiers::install_modifier(@_)}our%MAYBE_LOADED;sub _load_module {my$module=$_[0];my$file=module_notional_filename($module);use_package_optimistically($module);return 1 if$INC{$file};my$error=$@ || "Can't locate $file";my$stash=_getstash($module)||{};return 1 if grep +(!ref($_)and *$_{CODE}),values %$stash;return 1 if$INC{"Moose.pm"}&& Class::MOP::class_of($module)or Mouse::Util->can('find_meta')&& Mouse::Util::find_meta($module);die$error}sub _maybe_load_module {return$MAYBE_LOADED{$_[0]}if exists$MAYBE_LOADED{$_[0]};(my$proto=$_[0])=~ s/::/\//g;local $@;if (eval {require "${proto}.pm";1}){$MAYBE_LOADED{$_[0]}=1}else {if (exists$INC{"${proto}.pm"}){warn "$_[0] exists but failed to load with error: $@"}$MAYBE_LOADED{$_[0]}=0}return$MAYBE_LOADED{$_[0]}}sub _set_loaded {$INC{Module::Runtime::module_notional_filename($_[0])}||=$_[1]}sub _get_linear_isa {return mro::get_linear_isa($_[0])}sub _install_coderef {no warnings 'redefine';*{_getglob($_[0])}=_name_coderef(@_)}sub _name_coderef {shift if @_ > 2;can_haz_subname ? Sub::Name::subname(@_): $_[1]}sub _unimport_coderefs {my ($target,$info)=@_;return unless$info and my$exports=$info->{exports};my%rev=reverse %$exports;my$stash=_getstash($target);for my$name (keys %$exports){if ($stash->{$name}and defined(&{$stash->{$name}})){if ($rev{$target->can($name)}){my$old=delete$stash->{$name};my$full_name=join('::',$target,$name);for my$type (qw(SCALAR HASH ARRAY IO)){next unless defined(*{$old}{$type});no strict 'refs';*$full_name=*{$old}{$type}}}}}}if ($Config{useithreads}){require Moo::HandleMoose::_TypeMap}1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;if ($] >= 5.010){require mro}else {require MRO::Compat}1;
MOO__MRO

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;use strictures 1;use Moo::_Utils ();sub unimport {our$disarmed=1}sub Moo::HandleMoose::AuthorityHack::DESTROY {unless (our$disarmed or Moo::_Utils::_in_global_destruction){require Moo::HandleMoose;Moo::HandleMoose->import}}if ($INC{"Moose.pm"}){require Moo::HandleMoose;Moo::HandleMoose->import}else {$Moose::AUTHORITY=bless({},'Moo::HandleMoose::AuthorityHack')}1;
MOO_SIFICATION

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;use strict;use warnings;package Path::Tiny;our$VERSION='0.052';use Config;use Exporter 5.57 (qw/import/);use File::Spec 3.40 ();use Carp ();our@EXPORT=qw/path/;our@EXPORT_OK=qw/cwd rootdir tempfile tempdir/;use constant {PATH=>0,CANON=>1,VOL=>2,DIR=>3,FILE=>4,TEMP=>5,IS_BSD=>(scalar $^O =~ /bsd$/),IS_WIN32=>($^O eq 'MSWin32'),};use overload (q{""}=>sub {$_[0]->[PATH]},bool=>sub () {1},fallback=>1,);my$HAS_UU;sub _check_UU {eval {require Unicode::UTF8;Unicode::UTF8->VERSION(0.58);1}}my$HAS_FLOCK=$Config{d_flock}|| $Config{d_fcntl_can_lock}|| $Config{d_lockf};my$SLASH=qr{[\\/]};my$NOTSLASH=qr{[^\\/]};my$DRV_VOL=qr{[a-z]:}i;my$UNC_VOL=qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;my$WIN32_ROOT=qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;sub _win32_vol {my ($path,$drv)=@_;require Cwd;my$dcwd=eval {Cwd::getdcwd($drv)};$dcwd="$drv" unless defined$dcwd && length$dcwd;$dcwd =~ s{$SLASH?$}{/};$path =~ s{^$DRV_VOL}{$dcwd};return$path}sub _is_root {return IS_WIN32()? ($_[0]=~ /^$WIN32_ROOT$/): ($_[0]eq '/')}{package flock;use if Path::Tiny::IS_BSD(),'warnings::register'}my$WARNED_BSD_NFS=0;sub _throw {my ($self,$function,$file)=@_;if (IS_BSD()&& $function =~ /^flock/ && $! =~ /operation not supported/i &&!warnings::fatal_enabled('flock')){if (!$WARNED_BSD_NFS){warnings::warn(flock=>"No flock for NFS on BSD: continuing in unsafe mode");$WARNED_BSD_NFS++}}else {Path::Tiny::Error->throw($function,(defined$file ? $file : $self->[PATH]),$!)}return}sub _get_args {my ($raw,@valid)=@_;if (defined($raw)&& ref($raw)ne 'HASH'){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Options for $called_as must be a hash reference")}my$cooked={};for my$k (@valid){$cooked->{$k}=delete$raw->{$k}if exists$raw->{$k}}if (keys %$raw){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Invalid option(s) for $called_as: " .join(", ",keys %$raw))}return$cooked}sub path {my$path=shift;Carp::croak("path() requires a defined, positive-length argument")unless defined$path && length$path;$path="$path";if (IS_WIN32()){$path=_win32_vol($path,$1)if$path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};$path .= "/" if$path =~ m{^$UNC_VOL$}}if (@_){$path .= (_is_root($path)? "" : "/").join("/",@_)}my$cpath=$path=File::Spec->canonpath($path);$path =~ tr[\\][/] if IS_WIN32();$path .= "/" if IS_WIN32()&& $path =~ m{^$UNC_VOL$};if (_is_root($path)){$path =~ s{/?$}{/}}else {$path =~ s{/$}{}}if ($path =~ m{^(~[^/]*).*}){my ($homedir)=glob($1);$path =~ s{^(~[^/]*)}{$homedir}}bless [$path,$cpath ],__PACKAGE__}sub new {shift;path(@_)}sub cwd {require Cwd;return path(Cwd::getcwd())}sub rootdir {path(File::Spec->rootdir)}sub tempfile {shift if $_[0]eq 'Path::Tiny';my ($maybe_template,$args)=_parse_file_temp_args(@_);$args->{TEMPLATE}=$maybe_template->[0]if @$maybe_template;require File::Temp;my$temp=File::Temp->new(TMPDIR=>1,%$args);close$temp;my$self=path($temp)->absolute;$self->[TEMP]=$temp;return$self}sub tempdir {shift if $_[0]eq 'Path::Tiny';my ($maybe_template,$args)=_parse_file_temp_args(@_);require File::Temp;my$temp=File::Temp->newdir(@$maybe_template,TMPDIR=>1,%$args);my$self=path($temp)->absolute;$self->[TEMP]=$temp;return$self}sub _parse_file_temp_args {my$leading_template=(scalar(@_)% 2==1 ? shift(@_): '');my%args=@_;%args=map {uc($_),$args{$_}}keys%args;my@template=(exists$args{TEMPLATE}? delete$args{TEMPLATE}: $leading_template ? $leading_template : ());return (\@template,\%args)}sub _splitpath {my ($self)=@_;@{$self}[VOL,DIR,FILE ]=File::Spec->splitpath($self->[PATH])}sub absolute {my ($self,$base)=@_;if (IS_WIN32){return$self if length$self->volume;if ($self->is_absolute){require Cwd;my ($drv)=Win32::GetCwd()=~ /^($DRV_VOL | $UNC_VOL)/x;return path($drv .$self->[PATH])}}else {return$self if$self->is_absolute}require Cwd;return path((defined($base)? $base : Cwd::getcwd()),$_[0]->[PATH])}sub append {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },">>",$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close')}sub append_raw {splice @_,1,0,{binmode=>":unix" };goto&append}sub append_utf8 {if (defined($HAS_UU)? $HAS_UU : $HAS_UU=_check_UU()){my$self=shift;append($self,{binmode=>":unix" },map {Unicode::UTF8::encode_utf8($_)}@_)}else {splice @_,1,0,{binmode=>":unix:encoding(UTF-8)" };goto&append}}sub basename {my ($self)=@_;$self->_splitpath unless defined$self->[FILE];return$self->[FILE]}sub canonpath {$_[0]->[CANON]}sub child {my ($self,@parts)=@_;return path($self->[PATH],@parts)}sub children {my ($self,$filter)=@_;my$dh;opendir$dh,$self->[PATH]or $self->_throw('opendir');my@children=readdir$dh;closedir$dh or $self->_throw('closedir');if (not defined$filter){@children=grep {$_ ne '.' && $_ ne '..'}@children}elsif ($filter && ref($filter)eq 'Regexp'){@children=grep {$_ ne '.' && $_ ne '..' && $_ =~ $filter}@children}else {Carp::croak("Invalid argument '$filter' for children()")}return map {path($self->[PATH],$_)}@children}sub copy {my ($self,$dest)=@_;require File::Copy;File::Copy::copy($self->[PATH],$dest)or Carp::croak("copy failed for $self to $dest: $!")}sub digest {my ($self,$alg,@args)=@_;$alg='SHA-256' unless defined$alg;require Digest;return Digest->new($alg,@args)->add($self->slurp_raw)->hexdigest}sub dirname {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return length$self->[DIR]? $self->[DIR]: "."}sub exists {-e $_[0]->[PATH]}sub is_file {-f $_[0]->[PATH]}sub is_dir {-d $_[0]->[PATH]}sub filehandle {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);my ($opentype,$binmode)=@args;$opentype="<" unless defined$opentype;Carp::croak("Invalid file mode '$opentype'")unless grep {$opentype eq $_}qw/< +< > +> >> +>>/;$binmode=((caller(0))[10]|| {})->{'open' .substr($opentype,-1,1)}unless defined$binmode;$binmode="" unless defined$binmode;my ($fh,$lock,$trunc);if ($HAS_FLOCK && $args->{locked}){require Fcntl;if (grep {$opentype eq $_}qw(> +>)){my$flags=$opentype eq ">" ? Fcntl::O_WRONLY(): Fcntl::O_RDWR();$flags |=Fcntl::O_CREAT();sysopen($fh,$self->[PATH],$flags)or $self->_throw("sysopen");if ($binmode =~ s/^:unix//){binmode($fh,":raw")or $self->_throw("binmode (:raw)");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")or $self->_throw("binmode (:pop)")}}if (length$binmode){binmode($fh,$binmode)or $self->_throw("binmode ($binmode)")}$lock=Fcntl::LOCK_EX();$trunc=1}elsif ($^O eq 'aix' && $opentype eq "<"){$opentype="+<";$lock=Fcntl::LOCK_EX()}else {$lock=$opentype eq "<" ? Fcntl::LOCK_SH(): Fcntl::LOCK_EX()}}unless ($fh){my$mode=$opentype .$binmode;open$fh,$mode,$self->[PATH]or $self->_throw("open ($mode)")}do {flock($fh,$lock)or $self->_throw("flock ($lock)")}if$lock;do {truncate($fh,0)or $self->_throw("truncate")}if$trunc;return$fh}sub is_absolute {substr($_[0]->dirname,0,1)eq '/'}sub is_relative {substr($_[0]->dirname,0,1)ne '/'}sub is_rootdir {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return$self->[DIR]eq '/' && $self->[FILE]eq ''}sub iterator {my$self=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);my@dirs=$self;my$current;return sub {my$next;while (@dirs){if (ref$dirs[0]eq 'Path::Tiny'){if (!-r $dirs[0]){shift@dirs and next}$current=$dirs[0];my$dh;opendir($dh,$current->[PATH])or $self->_throw('opendir',$current->[PATH]);$dirs[0]=$dh;if (-l $current->[PATH]&&!$args->{follow_symlinks}){shift@dirs and next}}while (defined($next=readdir$dirs[0])){next if$next eq '.' || $next eq '..';my$path=$current->child($next);push@dirs,$path if$args->{recurse}&& -d $path &&!(!$args->{follow_symlinks}&& -l $path);return$path}shift@dirs}return}}sub lines {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);my$chomp=$args->{chomp};if ($args->{count}){my (@result,$counter);while (my$line=<$fh>){$line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if$chomp;push@result,$line;last if ++$counter==$args->{count}}return@result}elsif ($chomp){return map {s/(?:\x{0d}?\x{0a}|\x{0d})$//;$_}<$fh>}else {return wantarray ? <$fh> : (my$count=()=<$fh>)}}sub lines_raw {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ($args->{chomp}&&!$args->{count}){return split /\n/,slurp_raw($self)}else {$args->{binmode}=":raw";return lines($self,$args)}}sub lines_utf8 {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ((defined($HAS_UU)? $HAS_UU : $HAS_UU=_check_UU())&& $args->{chomp}&&!$args->{count}){return split /(?:\x{0d}?\x{0a}|\x{0d})/,slurp_utf8($self)}else {$args->{binmode}=":raw:encoding(UTF-8)";return lines($self,$args)}}sub mkpath {my ($self,$args)=@_;$args={}unless ref$args eq 'HASH';my$err;$args->{err}=\$err unless defined$args->{err};require File::Path;my@dirs=File::Path::make_path($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("mkpath failed for $file: $message")}return@dirs}sub move {my ($self,$dst)=@_;return rename($self->[PATH],$dst)|| $self->_throw('rename',$self->[PATH]."' -> '$dst'")}my%opens=(opena=>">>",openr=>"<",openw=>">",openrw=>"+<");while (my ($k,$v)=each%opens){no strict 'refs';*{$k}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);my ($binmode)=@args;$binmode=((caller(0))[10]|| {})->{'open' .substr($v,-1,1)}unless defined$binmode;$self->filehandle($args,$v,$binmode)};*{$k ."_raw"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw")};*{$k ."_utf8"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw:encoding(UTF-8)")}}sub parent {my ($self,$level)=@_;$level=1 unless defined$level && $level > 0;$self->_splitpath unless defined$self->[FILE];my$parent;if (length$self->[FILE]){if ($self->[FILE]eq '.' || $self->[FILE]eq ".."){$parent=path($self->[PATH]."/..")}else {$parent=path(_non_empty($self->[VOL].$self->[DIR]))}}elsif (length$self->[DIR]){if ($self->[DIR]=~ m{(?:^\.\./|/\.\./|/\.\.$)}){$parent=path($self->[VOL].$self->[DIR]."/..")}else {(my$dir=$self->[DIR])=~ s{/[^\/]+/$}{/};$parent=path($self->[VOL].$dir)}}else {$parent=path(_non_empty($self->[VOL]))}return$level==1 ? $parent : $parent->parent($level - 1)}sub _non_empty {my ($string)=shift;return ((defined($string)&& length($string))? $string : ".")}sub realpath {my$self=shift;require Cwd;my$realpath=eval {local$SIG{__WARN__}=sub {};Cwd::realpath($self->[PATH])};$self->_throw("resolving realpath")unless defined$realpath and length$realpath;return path($realpath)}sub relative {path(File::Spec->abs2rel($_[0]->[PATH],$_[1]))}sub remove {my$self=shift;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];return unlink$self->[PATH]|| $self->_throw('unlink')}sub remove_tree {my ($self,$args)=@_;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];$args={}unless ref$args eq 'HASH';my$err;$args->{err}=\$err unless defined$args->{err};$args->{safe}=1 unless defined$args->{safe};require File::Path;my$count=File::Path::remove_tree($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("remove_tree failed for $file: $message")}return$count}sub slurp {my$self=shift;my$args=_get_args(shift,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);if ((defined($binmode)? $binmode : "")eq ":unix" and my$size=-s $fh){my$buf;read$fh,$buf,$size;return$buf}else {local $/;return scalar <$fh>}}sub slurp_raw {$_[1]={binmode=>":unix" };goto&slurp}sub slurp_utf8 {if (defined($HAS_UU)? $HAS_UU : $HAS_UU=_check_UU()){return Unicode::UTF8::decode_utf8(slurp($_[0],{binmode=>":unix" }))}else {$_[1]={binmode=>":raw:encoding(UTF-8)" };goto&slurp}}sub spew {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$temp=path($self->[PATH].$$ .int(rand(2**31)));my$fh=$temp->filehandle({locked=>1 },">",$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close',$temp->[PATH]);my$resolved_path=$self->[PATH];$resolved_path=readlink$resolved_path while -l $resolved_path;return$temp->move($resolved_path)}sub spew_raw {splice @_,1,0,{binmode=>":unix" };goto&spew}sub spew_utf8 {if (defined($HAS_UU)? $HAS_UU : $HAS_UU=_check_UU()){my$self=shift;spew($self,{binmode=>":unix" },map {Unicode::UTF8::encode_utf8($_)}@_)}else {splice @_,1,0,{binmode=>":unix:encoding(UTF-8)" };goto&spew}}sub stat {my$self=shift;require File::stat;return File::stat::stat($self->[PATH])|| $self->_throw('stat')}sub lstat {my$self=shift;require File::stat;return File::stat::lstat($self->[PATH])|| $self->_throw('lstat')}sub stringify {$_[0]->[PATH]}sub subsumes {my$self=shift;Carp::croak("subsumes() requires a defined, positive-length argument")unless defined $_[0];my$other=path(shift);if ($self->is_absolute &&!$other->is_absolute){$other=$other->absolute}elsif ($other->is_absolute &&!$self->is_absolute){$self=$self->absolute}if (length$self->volume &&!length$other->volume){$other=$other->absolute}elsif (length$other->volume &&!length$self->volume){$self=$self->absolute}if ($self->[PATH]eq '.'){return!!1}elsif ($self->is_rootdir){return$other->[PATH]=~ m{^\Q$self->[PATH]\E}}else {return$other->[PATH]=~ m{^\Q$self->[PATH]\E(?:/|$)}}}sub touch {my ($self,$epoch)=@_;if (!-e $self->[PATH]){my$fh=$self->openw;close$fh or $self->_throw('close')}$epoch=defined($epoch)? $epoch : time();utime$epoch,$epoch,$self->[PATH]or $self->_throw("utime ($epoch)");return$self}sub touchpath {my ($self)=@_;my$parent=$self->parent;$parent->mkpath unless$parent->exists;$self->touch}sub volume {my ($self)=@_;$self->_splitpath unless defined$self->[VOL];return$self->[VOL]}package Path::Tiny::Error;our@CARP_NOT=qw/Path::Tiny/;use overload (q{""}=>sub {(shift)->{msg}},fallback=>1);sub throw {my ($class,$op,$file,$err)=@_;chomp(my$trace=Carp::shortmess);my$msg="Error $op on '$file': $err$trace\n";die bless {op=>$op,file=>$file,err=>$err,msg=>$msg },$class}1;
PATH_TINY

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;use strictures 1;use base qw(Exporter);use Moo::_Utils;use Scalar::Util qw(weaken);our$VERSION='1.004002';$VERSION=eval$VERSION;our@EXPORT=qw(defer_sub undefer_sub undefer_all);our%DEFERRED;sub undefer_sub {my ($deferred)=@_;my ($target,$maker,$undeferred_ref)=@{$DEFERRED{$deferred}||return$deferred};return ${$undeferred_ref}if ${$undeferred_ref};${$undeferred_ref}=my$made=$maker->();if (defined($target)&& $deferred eq *{_getglob($target)}{CODE}||''){no warnings 'redefine';*{_getglob($target)}=$made}weaken($DEFERRED{$made}=$DEFERRED{$deferred});return$made}sub undefer_all {undefer_sub($_)for keys%DEFERRED;return}sub defer_info {my ($deferred)=@_;$DEFERRED{$deferred||''}}sub defer_sub {my ($target,$maker)=@_;my$undeferred;my$deferred_info;my$deferred=sub {$undeferred ||=undefer_sub($deferred_info->[3]);goto &$undeferred};$deferred_info=[$target,$maker,\$undeferred,$deferred ];weaken($DEFERRED{$deferred}=$deferred_info);_install_coderef($target=>$deferred)if defined$target;return$deferred}sub CLONE {%DEFERRED=map {defined $_ ? ($_->[3]=>$_): ()}values%DEFERRED;weaken($_)for values%DEFERRED}1;
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;use strict;use warnings;our$VERSION='0.001011';use Carp ();use List::Util ();sub import {my ($self,@args)=@_;my$inner_target=caller;my$export_data=sub_export_options($inner_target,@args);my$full_exporter;no strict 'refs';@{"${inner_target}::EXPORT_OK"}=@{$export_data->{exports}};@{"${inner_target}::EXPORT"}=@{$export_data->{defaults}};%{"${inner_target}::EXPORT_TAGS"}=%{$export_data->{tags}};*{"${inner_target}::import"}=sub {use strict;my ($self,@args)=@_;if (List::Util::first {ref ||!m/ \A [:-]? \w+ \z /xm}@args){Carp::croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed' unless eval {require Sub::Exporter};$full_exporter ||=Sub::Exporter::build_exporter($export_data->{original});goto$full_exporter}elsif (defined(my$num=List::Util::first {!ref and m/^\d/}@args)){die "cannot export symbols with a leading digit: '$num'"}else {require Exporter;s/ \A - /:/xm for@args;@_=($self,@args);goto \&Exporter::import}};return}my$too_complicated=<<'DEATH';sub sub_export_options {my ($inner_target,$setup,$options)=@_;my@exports;my@defaults;my%tags;if ($setup eq '-setup'){my%options=%$options;OPTIONS: for my$opt (keys%options){if ($opt eq 'exports'){Carp::croak$too_complicated if ref$options{exports}ne 'ARRAY';@exports=@{$options{exports}};Carp::croak$too_complicated if List::Util::first {ref}@exports}elsif ($opt eq 'groups'){%tags=%{$options{groups}};for my$tagset (values%tags){Carp::croak$too_complicated if List::Util::first {/ \A - (?! all \b ) /x || ref}@{$tagset}}@defaults=@{$tags{default}|| []}}else {Carp::croak$too_complicated}}@{$_}=map {/ \A  [:-] all \z /x ? @exports : $_}@{$_}for \@defaults,values%tags;$tags{all}||=[@exports ];my%exports=map {$_=>1}@exports;my@errors=grep {not $exports{$_}}@defaults;Carp::croak join(', ',@errors)." is not exported by the $inner_target module\n" if@errors}return {exports=>\@exports,defaults=>\@defaults,original=>$options,tags=>\%tags,}}1;
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;use strictures 1;sub _clean_eval {eval $_[0]}use Sub::Defer;use B 'perlstring';use Scalar::Util qw(weaken);use base qw(Exporter);our$VERSION='1.004002';$VERSION=eval$VERSION;our@EXPORT=qw(quote_sub unquote_sub quoted_from_sub);our%QUOTED;our%WEAK_REFS;sub capture_unroll {my ($from,$captures,$indent)=@_;join('',map {/^([\@\%\$])/ or die "capture key should start with \@, \% or \$: $_";(' ' x $indent).qq{my ${_} = ${1}{${from}->{${\perlstring $_}}};\n}}keys %$captures)}sub inlinify {my ($code,$args,$extra,$local)=@_;my$do='do { '.($extra||'');if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//){$do .= $1}my$assign='';if (my ($code_args)=$code =~ /^\s*my\s*\(([^)]+)\)\s*=\s*\@_;$/s){if ($code_args ne $args){$assign='my ('.$code_args.') = ('.$args.'); '}}elsif ($local || $args ne '@_'){$assign=($local ? 'local ' : '').'@_ = ('.$args.'); '}$do.$assign.$code.' }'}sub quote_sub {my$options=(ref($_[-1])eq 'HASH' and ref($_[-2])eq 'HASH')? pop : {};my$captures=ref($_[-1])eq 'HASH' ? pop : undef;undef($captures)if$captures &&!keys %$captures;my$code=pop;my$name=$_[0];my ($package,$hints,$bitmask,$hintshash)=(caller(0))[0,8,9,10];my$context ="package $package;\n" ."BEGIN {\n" ."  \$^H = ".B::perlstring($hints).";\n" ."  \${^WARNING_BITS} = ".B::perlstring($bitmask).";\n" ."  \%^H = (\n" .join('',map "    ".B::perlstring($_)." => ".B::perlstring($hintshash->{$_}).",",keys %$hintshash)."  );\n" ."}\n";$code="$context$code";my$quoted_info;my$deferred=defer_sub +($options->{no_install}? undef : $name)=>sub {unquote_sub($quoted_info->[4])};$quoted_info=[$name,$code,$captures,undef,$deferred ];weaken($QUOTED{$deferred}=$quoted_info);return$deferred}sub quoted_from_sub {my ($sub)=@_;$QUOTED{$sub||''}}sub unquote_sub {my ($sub)=@_;unless ($QUOTED{$sub}[3]){my ($name,$code,$captures)=@{$QUOTED{$sub}};my$make_sub="{\n";my%captures=$captures ? %$captures : ();$captures{'$_QUOTED'}=\$QUOTED{$sub};$make_sub .= capture_unroll("\$_[1]",\%captures,2);$make_sub .= ($name ? "  no warnings 'closure';\n  sub ${name} {\n" : "  \$_QUOTED->[3] = sub {\n");$make_sub .= $code;$make_sub .= "  }".($name ? '' : ';')."\n";if ($name){$make_sub .= "  \$_QUOTED->[3] = \\&${name}\n"}$make_sub .= "}\n1;\n";$ENV{SUB_QUOTE_DEBUG}&& warn$make_sub;{no strict 'refs';local *{$name}if$name;my ($success,$e);{local $@;$success=_clean_eval($make_sub,\%captures);$e=$@}unless ($success){die "Eval went very, very wrong:\n\n${make_sub}\n\n$e"}}}$QUOTED{$sub}[3]}sub CLONE {%QUOTED=map {defined $_ ? ($_->[4]=>$_): ()}values%QUOTED;weaken($_)for values%QUOTED}1;
SUB_QUOTE

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;use strictures 1;use Moo::_Utils;sub moo {print <<'EOMOO';exit 0}BEGIN {my$package;sub import {moo()if $0 eq '-';$package=$_[1]|| 'Class';if ($package =~ /^\+/){$package =~ s/^\+//;_load_module($package)}}use Filter::Simple sub {s/^/package $package;\nuse Moo;\n/}}1;
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
OO

$fatpacked{"strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRICTURES';
  package strictures;use strict;use warnings FATAL=>'all';BEGIN {*_PERL_LT_5_8_4=($] < 5.008004)? sub(){1}: sub(){0}}our$VERSION='1.005004';sub VERSION {my ($class,$version)=@_;for ($version){last unless defined &&!ref && int!=1;die "Major version specified as $_ - this is strictures version 1"}no warnings 'uninitialized';shift->SUPER::VERSION(@_)}our$extra_load_states;our$Smells_Like_VCS=(-e '.git' || -e '.svn' || -e '.hg' || (-e '../../dist.ini' && (-e '../../.git' || -e '../../.svn' || -e '../../.hg')));sub import {strict->import;warnings->import(FATAL=>'all');my$extra_tests=do {if (exists$ENV{PERL_STRICTURES_EXTRA}){if (_PERL_LT_5_8_4 and $ENV{PERL_STRICTURES_EXTRA}){die 'PERL_STRICTURES_EXTRA checks are not available on perls older than 5.8.4: ' ."please unset \$ENV{PERL_STRICTURES_EXTRA}\n"}$ENV{PERL_STRICTURES_EXTRA}}elsif (!_PERL_LT_5_8_4){!!((caller)[1]=~ /^(?:t|xt|lib|blib)/ and $Smells_Like_VCS)}};if ($extra_tests){$extra_load_states ||=do {my (%rv,@failed);for my$mod (qw(indirect multidimensional bareword::filehandles)){eval "require $mod; \$rv{'$mod'} = 1;" or do {push@failed,$mod;(my$file=$mod)=~ s|::|/|g;delete$INC{"${file}.pm"}}}if (@failed){my$failed=join ' ',@failed;print STDERR <<EOE}\%rv};indirect->unimport(':fatal')if$extra_load_states->{indirect};multidimensional->unimport if$extra_load_states->{multidimensional};bareword::filehandles->unimport if$extra_load_states->{'bareword::filehandles'}}}1;
  strictures.pm extra testing active but couldn't load all modules. Missing were:
  
    $failed
  
  Extra testing is auto-enabled in checkouts only, so if you're the author
  of a strictures-using module you need to run:
  
    cpan indirect multidimensional bareword::filehandles
  
  but these modules are not required by your users.
  EOE
STRICTURES

$fatpacked{"x86_64-linux/Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CWD';
  package Cwd;use strict;use Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);$VERSION='3.40';my$xs_version=$VERSION;$VERSION =~ tr/_//;@ISA=qw/Exporter/;@EXPORT=qw(cwd getcwd fastcwd fastgetcwd);push@EXPORT,qw(getdcwd) if $^O eq 'MSWin32';@EXPORT_OK=qw(chdir abs_path fast_abs_path realpath fast_realpath);if ($^O eq 'os2'){local $^W=0;*cwd=defined&sys_cwd ? \&sys_cwd : \&_os2_cwd;*getcwd=\&cwd;*fastgetcwd=\&cwd;*fastcwd=\&cwd;*fast_abs_path=\&sys_abspath if defined&sys_abspath;*abs_path=\&fast_abs_path;*realpath=\&fast_abs_path;*fast_realpath=\&fast_abs_path;return 1}my$use_vms_feature;BEGIN {if ($^O eq 'VMS'){if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_vms_feature=1}}}sub _vms_unix_rpt {my$unix_rpt;if ($use_vms_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub _vms_efs {my$efs;if ($use_vms_feature){$efs=VMS::Feature::current("efs_charset")}else {my$env_efs=$ENV{'DECC$EFS_CHARSET'}|| '';$efs=$env_efs =~ /^[ET1]/i}return$efs}eval {if ($] >= 5.006){require XSLoader;XSLoader::load(__PACKAGE__,$xs_version)}else {require DynaLoader;push@ISA,'DynaLoader';__PACKAGE__->bootstrap($xs_version)}};my%METHOD_MAP=(VMS=>{cwd=>'_vms_cwd',getcwd=>'_vms_cwd',fastcwd=>'_vms_cwd',fastgetcwd=>'_vms_cwd',abs_path=>'_vms_abs_path',fast_abs_path=>'_vms_abs_path',},MSWin32=>{cwd=>'_NT_cwd',getcwd=>'_NT_cwd',fastcwd=>'_NT_cwd',fastgetcwd=>'_NT_cwd',abs_path=>'fast_abs_path',realpath=>'fast_abs_path',},dos=>{cwd=>'_dos_cwd',getcwd=>'_dos_cwd',fastgetcwd=>'_dos_cwd',fastcwd=>'_dos_cwd',abs_path=>'fast_abs_path',},qnx=>{cwd=>'_qnx_cwd',getcwd=>'_qnx_cwd',fastgetcwd=>'_qnx_cwd',fastcwd=>'_qnx_cwd',abs_path=>'_qnx_abs_path',fast_abs_path=>'_qnx_abs_path',},cygwin=>{getcwd=>'cwd',fastgetcwd=>'cwd',fastcwd=>'cwd',abs_path=>'fast_abs_path',realpath=>'fast_abs_path',},epoc=>{cwd=>'_epoc_cwd',getcwd=>'_epoc_cwd',fastgetcwd=>'_epoc_cwd',fastcwd=>'_epoc_cwd',abs_path=>'fast_abs_path',},MacOS=>{getcwd=>'cwd',fastgetcwd=>'cwd',fastcwd=>'cwd',abs_path=>'fast_abs_path',},);$METHOD_MAP{NT}=$METHOD_MAP{MSWin32};my$pwd_cmd;for my$try ('/bin/pwd','/usr/bin/pwd','/QOpenSys/bin/pwd',){if(-x $try){$pwd_cmd=$try;last}}my$found_pwd_cmd=defined($pwd_cmd);unless ($pwd_cmd){$pwd_cmd='pwd'}sub _carp {require Carp;Carp::carp(@_)}sub _croak {require Carp;Carp::croak(@_)}sub _backtick_pwd {my@localize=grep exists$ENV{$_},qw(PATH IFS CDPATH ENV BASH_ENV);local@ENV{@localize};my$cwd=`$pwd_cmd`;local $/="\n";chomp($cwd)if defined$cwd;$cwd}unless ($METHOD_MAP{$^O}{cwd}or defined&cwd){my$sep=$Config::Config{path_sep}|| ':';my$os=$^O;if (defined$ENV{PATH}and $os ne 'MSWin32'){my@candidates=split($sep,$ENV{PATH});while (!$found_pwd_cmd and @candidates){my$candidate=shift@candidates;$found_pwd_cmd=1 if -x "$candidate/pwd"}}if($os eq 'MacOS' || $found_pwd_cmd){*cwd=\&_backtick_pwd}else {*cwd=\&getcwd}}if ($^O eq 'cygwin'){local $^W=0;my$orig_cwd=\&cwd;*cwd=sub {&$orig_cwd()}}*fastgetcwd=\&cwd;sub _perl_getcwd {abs_path('.')}sub fastcwd_ {my($odev,$oino,$cdev,$cino,$tdev,$tino);my(@path,$path);local(*DIR);my($orig_cdev,$orig_cino)=stat('.');($cdev,$cino)=($orig_cdev,$orig_cino);for (;;){my$direntry;($odev,$oino)=($cdev,$cino);CORE::chdir('..')|| return undef;($cdev,$cino)=stat('.');last if$odev==$cdev && $oino==$cino;opendir(DIR,'.')|| return undef;for (;;){$direntry=readdir(DIR);last unless defined$direntry;next if$direntry eq '.';next if$direntry eq '..';($tdev,$tino)=lstat($direntry);last unless$tdev!=$odev || $tino!=$oino}closedir(DIR);return undef unless defined$direntry;unshift(@path,$direntry)}$path='/' .join('/',@path);if ($^O eq 'apollo'){$path="/".$path}$path =~ /^(.*)\z/s && CORE::chdir($1)or return undef;($cdev,$cino)=stat('.');die "Unstable directory path, current directory changed unexpectedly" if$cdev!=$orig_cdev || $cino!=$orig_cino;$path}if (not defined&fastcwd){*fastcwd=\&fastcwd_}my$chdir_init=0;sub chdir_init {if ($ENV{'PWD'}and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32'){my($dd,$di)=stat('.');my($pd,$pi)=stat($ENV{'PWD'});if (!defined$dd or!defined$pd or $di!=$pi or $dd!=$pd){$ENV{'PWD'}=cwd()}}else {my$wd=cwd();$wd=Win32::GetFullPathName($wd)if $^O eq 'MSWin32';$ENV{'PWD'}=$wd}if ($^O ne 'MSWin32' and $ENV{'PWD'}=~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s){my($pd,$pi)=stat($2);my($dd,$di)=stat($1);if (defined$pd and defined$dd and $di==$pi and $dd==$pd){$ENV{'PWD'}="$2$3"}}$chdir_init=1}sub chdir {my$newdir=@_ ? shift : '';$newdir =~ s|///*|/|g unless $^O eq 'MSWin32';chdir_init()unless$chdir_init;my$newpwd;if ($^O eq 'MSWin32'){$newpwd=Win32::GetFullPathName($newdir)}return 0 unless CORE::chdir$newdir;if ($^O eq 'VMS'){return$ENV{'PWD'}=$ENV{'DEFAULT'}}elsif ($^O eq 'MacOS'){return$ENV{'PWD'}=cwd()}elsif ($^O eq 'MSWin32'){$ENV{'PWD'}=$newpwd;return 1}if (ref$newdir eq 'GLOB'){$ENV{'PWD'}=cwd()}elsif ($newdir =~ m#^/#s){$ENV{'PWD'}=$newdir}else {my@curdir=split(m#/#,$ENV{'PWD'});@curdir=('')unless@curdir;my$component;for$component (split(m#/#,$newdir)){next if$component eq '.';pop(@curdir),next if$component eq '..';push(@curdir,$component)}$ENV{'PWD'}=join('/',@curdir)|| '/'}1}sub _perl_abs_path {my$start=@_ ? shift : '.';my($dotdots,$cwd,@pst,@cst,$dir,@tst);unless (@cst=stat($start)){_carp("stat($start): $!");return ''}unless (-d _){my ($dir,$file)=$start =~ m{^(.*)/(.+)$} or return cwd().'/' .$start;if (-l $start){my$link_target=readlink($start);die "Can't resolve link $start: $!" unless defined$link_target;require File::Spec;$link_target=$dir .'/' .$link_target unless File::Spec->file_name_is_absolute($link_target);return abs_path($link_target)}return$dir ? abs_path($dir)."/$file" : "/$file"}$cwd='';$dotdots=$start;do {$dotdots .= '/..';@pst=@cst;local*PARENT;unless (opendir(PARENT,$dotdots)){require File::Spec;return File::Spec->rel2abs($start,_backtick_pwd())}unless (@cst=stat($dotdots)){_carp("stat($dotdots): $!");closedir(PARENT);return ''}if ($pst[0]==$cst[0]&& $pst[1]==$cst[1]){$dir=undef}else {do {unless (defined ($dir=readdir(PARENT))){_carp("readdir($dotdots): $!");closedir(PARENT);return ''}$tst[0]=$pst[0]+1 unless (@tst=lstat("$dotdots/$dir"))}while ($dir eq '.' || $dir eq '..' || $tst[0]!=$pst[0]|| $tst[1]!=$pst[1])}$cwd=(defined$dir ? "$dir" : "")."/$cwd" ;closedir(PARENT)}while (defined$dir);chop($cwd)unless$cwd eq '/';$cwd}my$Curdir;sub fast_abs_path {local$ENV{PWD}=$ENV{PWD}|| '';my$cwd=getcwd();require File::Spec;my$path=@_ ? shift : ($Curdir ||=File::Spec->curdir);($path)=$path =~ /(.*)/s;($cwd)=$cwd =~ /(.*)/s;unless (-e $path){_croak("$path: No such file or directory")}unless (-d _){my ($vol,$dir,$file)=File::Spec->splitpath($path);return File::Spec->catfile($cwd,$path)unless length$dir;if (-l $path){my$link_target=readlink($path);die "Can't resolve link $path: $!" unless defined$link_target;$link_target=File::Spec->catpath($vol,$dir,$link_target)unless File::Spec->file_name_is_absolute($link_target);return fast_abs_path($link_target)}return$dir eq File::Spec->rootdir ? File::Spec->catpath($vol,$dir,$file): fast_abs_path(File::Spec->catpath($vol,$dir,'')).'/' .$file}if (!CORE::chdir($path)){_croak("Cannot chdir to $path: $!")}my$realpath=getcwd();if (!((-d $cwd)&& (CORE::chdir($cwd)))){_croak("Cannot chdir back to $cwd: $!")}$realpath}*fast_realpath=\&fast_abs_path;sub _vms_cwd {return$ENV{'DEFAULT'}}sub _vms_abs_path {return$ENV{'DEFAULT'}unless @_;my$path=shift;my$efs=_vms_efs;my$unix_rpt=_vms_unix_rpt;if (defined&VMS::Filespec::vmsrealpath){my$path_unix=0;my$path_vms=0;$path_unix=1 if ($path =~ m#(?<=\^)/#);$path_unix=1 if ($path =~ /^\.\.?$/);$path_vms=1 if ($path =~ m#[\[<\]]#);$path_vms=1 if ($path =~ /^--?$/);my$unix_mode=$path_unix;if ($efs){if ($path_vms==$path_unix){$unix_mode=$unix_rpt}else {$unix_mode=0 if$path_vms}}if ($unix_mode){return VMS::Filespec::unixrealpath($path)}my$new_path=VMS::Filespec::vmsrealpath($path);$new_path=VMS::Filespec::pathify($new_path)if -d $path;return$new_path}if (-l $path){my$link_target=readlink($path);die "Can't resolve link $path: $!" unless defined$link_target;return _vms_abs_path($link_target)}my$pathified=VMS::Filespec::pathify($path);$path=$pathified if defined$pathified;return VMS::Filespec::rmsexpand($path)}sub _os2_cwd {$ENV{'PWD'}=`cmd /c cd`;chomp$ENV{'PWD'};$ENV{'PWD'}=~ s:\\:/:g ;return$ENV{'PWD'}}sub _win32_cwd_simple {$ENV{'PWD'}=`cd`;chomp$ENV{'PWD'};$ENV{'PWD'}=~ s:\\:/:g ;return$ENV{'PWD'}}sub _win32_cwd {if (*{$DynaLoader::{boot_DynaLoader}}{CODE}){$ENV{'PWD'}=Win32::GetCwd()}else {chomp($ENV{'PWD'}=`cd`)}$ENV{'PWD'}=~ s:\\:/:g ;return$ENV{'PWD'}}*_NT_cwd=defined&Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;sub _dos_cwd {if (!defined&Dos::GetCwd){$ENV{'PWD'}=`command /c cd`;chomp$ENV{'PWD'};$ENV{'PWD'}=~ s:\\:/:g }else {$ENV{'PWD'}=Dos::GetCwd()}return$ENV{'PWD'}}sub _qnx_cwd {local$ENV{PATH}='';local$ENV{CDPATH}='';local$ENV{ENV}='';$ENV{'PWD'}=`/usr/bin/fullpath -t`;chomp$ENV{'PWD'};return$ENV{'PWD'}}sub _qnx_abs_path {local$ENV{PATH}='';local$ENV{CDPATH}='';local$ENV{ENV}='';my$path=@_ ? shift : '.';local*REALPATH;defined(open(REALPATH,'-|')|| exec '/usr/bin/fullpath','-t',$path)or die "Can't open /usr/bin/fullpath: $!";my$realpath=<REALPATH>;close REALPATH;chomp$realpath;return$realpath}sub _epoc_cwd {$ENV{'PWD'}=EPOC::getcwd();return$ENV{'PWD'}}if (exists$METHOD_MAP{$^O}){my$map=$METHOD_MAP{$^O};for my$name (keys %$map){local $^W=0;no strict 'refs';*{$name}=\&{$map->{$name}}}}*abs_path=\&_perl_abs_path unless defined&abs_path;*getcwd=\&_perl_getcwd unless defined&getcwd;*realpath=\&abs_path;1;
X86_64-LINUX_CWD

$fatpacked{"x86_64-linux/Devel/GlobalDestruction/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_DEVEL_GLOBALDESTRUCTION_XS';
  package Devel::GlobalDestruction::XS;use strict;use warnings;our$VERSION='0.01';require XSLoader;XSLoader::load(__PACKAGE__,$VERSION);1;
X86_64-LINUX_DEVEL_GLOBALDESTRUCTION_XS

$fatpacked{"x86_64-linux/File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC';
  package File::Spec;use strict;use vars qw(@ISA $VERSION);$VERSION='3.40';$VERSION =~ tr/_//;my%module=(MacOS=>'Mac',MSWin32=>'Win32',os2=>'OS2',VMS=>'VMS',epoc=>'Epoc',NetWare=>'Win32',symbian=>'Win32',dos=>'OS2',cygwin=>'Cygwin');my$module=$module{$^O}|| 'Unix';require "File/Spec/$module.pm";@ISA=("File::Spec::$module");1;
X86_64-LINUX_FILE_SPEC

$fatpacked{"x86_64-linux/File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);sub canonpath {my($self,$path)=@_;return unless defined$path;$path =~ s|\\|/|g;my$node='';if ($path =~ s@^(//[^/]+)(?:/|\z)@/@s){$node=$1}return$node .$self->SUPER::canonpath($path)}sub catdir {my$self=shift;return unless @_;if ($_[0]and ($_[0]eq '/' or $_[0]eq '\\')){shift;return$self->SUPER::catdir('',@_)}$self->SUPER::catdir(@_)}sub file_name_is_absolute {my ($self,$file)=@_;return 1 if$file =~ m{^([a-z]:)?[\\/]}is;return$self->SUPER::file_name_is_absolute($file)}my$tmpdir;sub tmpdir {return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir($ENV{TMPDIR},"/tmp",$ENV{'TMP'},$ENV{'TEMP'},'C:/temp')}sub case_tolerant {return 1 unless $^O eq 'cygwin' and defined&Cygwin::mount_flags;my$drive=shift;if (!$drive){my@flags=split(/,/,Cygwin::mount_flags('/cygwin'));my$prefix=pop(@flags);if (!$prefix || $prefix eq 'cygdrive'){$drive='/cygdrive/c'}elsif ($prefix eq '/'){$drive='/c'}else {$drive="$prefix/c"}}my$mntopts=Cygwin::mount_flags($drive);if ($mntopts and ($mntopts =~ /,managed/)){return 0}eval {require Win32API::File}or return 1;my$osFsType="\0"x256;my$osVolName="\0"x256;my$ouFsFlags=0;Win32API::File::GetVolumeInformation($drive,$osVolName,256,[],[],$ouFsFlags,$osFsType,256);if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()){return 0}else {return 1}}1;
X86_64-LINUX_FILE_SPEC_CYGWIN

$fatpacked{"x86_64-linux/File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_EPOC';
  package File::Spec::Epoc;use strict;use vars qw($VERSION @ISA);$VERSION='3.40';$VERSION =~ tr/_//;require File::Spec::Unix;@ISA=qw(File::Spec::Unix);sub case_tolerant {return 1}sub canonpath {my ($self,$path)=@_;return unless defined$path;$path =~ s|/+|/|g;$path =~ s|(/\.)+/|/|g;$path =~ s|^(\./)+||s unless$path eq "./";$path =~ s|^/(\.\./)+|/|s;$path =~ s|/\Z(?!\n)|| unless$path eq "/";return$path}1;
X86_64-LINUX_FILE_SPEC_EPOC

$fatpacked{"x86_64-linux/File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;use File::Spec;use strict;use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);$VERSION='3.40';$VERSION =~ tr/_//;require Exporter;@ISA=qw(Exporter);@EXPORT=qw(canonpath catdir catfile curdir rootdir updir no_upwards file_name_is_absolute path);@EXPORT_OK=qw(devnull tmpdir splitpath splitdir catpath abs2rel rel2abs case_tolerant);%EXPORT_TAGS=(ALL=>[@EXPORT_OK,@EXPORT ]);for my$meth (@EXPORT,@EXPORT_OK){my$sub=File::Spec->can($meth);no strict 'refs';*{$meth}=sub {&$sub('File::Spec',@_)}}1;
X86_64-LINUX_FILE_SPEC_FUNCTIONS

$fatpacked{"x86_64-linux/File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_MAC';
  package File::Spec::Mac;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);my$macfiles;if ($^O eq 'MacOS'){$macfiles=eval {require Mac::Files}}sub case_tolerant {1}sub canonpath {my ($self,$path)=@_;return$path}sub catdir {my$self=shift;return '' unless @_;my@args=@_;my$first_arg;my$relative;if ($args[0]eq ''){shift@args;$relative=0;$first_arg=$self->rootdir}elsif ($args[0]=~ /^[^:]+:/){$relative=0;$first_arg=shift@args;$first_arg="$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/)}else {$relative=1;if ($args[0]=~ /^::+\Z(?!\n)/){$first_arg=':'}elsif ($args[0]eq ':'){$first_arg=shift@args}else {$first_arg=shift@args;$first_arg="$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/)}}my$result=$first_arg;while (@args){my$arg=shift@args;unless (($arg eq '')|| ($arg eq ':')){if ($arg =~ /^::+\Z(?!\n)/){my$updir_count=length($arg)- 1;while ((@args)&& ($args[0]=~ /^::+\Z(?!\n)/)){$arg=shift@args;$updir_count += (length($arg)- 1)}$arg=(':' x $updir_count)}else {$arg =~ s/^://s;$arg="$arg:" unless ($arg =~ /:\Z(?!\n)/)}$result .= $arg}}if (($relative)&& ($result !~ /^:/)){$result=":$result"}unless ($relative){$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/}return$result}sub catfile {my$self=shift;return '' unless @_;my$file=pop @_;return$file unless @_;my$dir=$self->catdir(@_);$file =~ s/^://s;return$dir.$file}sub curdir {return ":"}sub devnull {return "Dev:Null"}sub rootdir {return '' unless$macfiles;my$system=Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,&Mac::Files::kSystemFolderType);$system =~ s/:.*\Z(?!\n)/:/s;return$system}my$tmpdir;sub tmpdir {return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir($ENV{TMPDIR})}sub updir {return "::"}sub file_name_is_absolute {my ($self,$file)=@_;if ($file =~ /:/){return (!($file =~ m/^:/s))}elsif ($file eq ''){return 1 }else {return 0}}sub path {return unless exists$ENV{Commands};return split(/,/,$ENV{Commands})}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file);if ($nofile){($volume,$directory)=$path =~ m|^((?:[^:]+:)?)(.*)|s}else {$path =~ m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;$volume=$1;$directory=$2;$file=$3}$volume='' unless defined($volume);$directory=":$directory" if ($volume && $directory);if ($directory){$directory .= ':' unless (substr($directory,-1)eq ':');$directory=":$directory" unless (substr($directory,0,1)eq ':')}else {$directory=''}$file='' unless defined($file);return ($volume,$directory,$file)}sub splitdir {my ($self,$path)=@_;my@result=();my ($head,$sep,$tail,$volume,$directories);return@result if ((!defined($path))|| ($path eq ''));return (':')if ($path eq ':');($volume,$sep,$directories)=$path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;if ($volume){push (@result,$volume);$sep .= ':'}while ($sep || $directories){if (length($sep)> 1){my$updir_count=length($sep)- 1;for (my$i=0;$i<$updir_count;$i++){push (@result,'::')}}$sep='';if ($directories){($head,$sep,$tail)=$directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;push (@result,$head);$directories=$tail}}return@result}sub catpath {my ($self,$volume,$directory,$file)=@_;if ((!$volume)&& (!$directory)){$file =~ s/^:// if$file;return$file }my ($dir_volume,$dir_dirs)=$self->splitpath($directory,1);$volume=$dir_volume unless length$volume;my$path=$volume;$path .= ':' unless (substr($path,-1)eq ':');if ($directory){$directory=$dir_dirs if$volume;$directory =~ s/^://;$path .= $directory;$path .= ':' unless (substr($path,-1)eq ':')}if ($file){$file =~ s/^://;$path .= $file}return$path}sub _resolve_updirs {my$path=shift @_;my$proceed;do {$proceed=($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/)}while ($proceed);return$path}sub abs2rel {my($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){$path=$self->rel2abs($path)}if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base);$base=_resolve_updirs($base)}else {$base=_resolve_updirs($base)}my ($path_vol,$path_dirs,$path_file)=$self->splitpath($path);my ($base_vol,$base_dirs)=$self->splitpath($base);return$path unless lc($path_vol)eq lc($base_vol);my@pathchunks=$self->splitdir($path_dirs);my@basechunks=$self->splitdir($base_dirs);while (@pathchunks && @basechunks && lc($pathchunks[0])eq lc($basechunks[0])){shift@pathchunks ;shift@basechunks }$path_dirs=$self->catdir(':',@pathchunks);$base_dirs=(':' x @basechunks).':' ;return$self->catpath('',$self->catdir($base_dirs,$path_dirs),$path_file)}sub rel2abs {my ($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}my ($path_dirs,$path_file)=($self->splitpath($path))[1,2];my ($base_vol,$base_dirs)=$self->splitpath($base);$path_dirs=':' if ($path_dirs eq '');$base_dirs =~ s/:$//;$base_dirs=$base_dirs .$path_dirs;$path=$self->catpath($base_vol,$base_dirs,$path_file)}return$path}1;
X86_64-LINUX_FILE_SPEC_MAC

$fatpacked{"x86_64-linux/File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_OS2';
  package File::Spec::OS2;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);sub devnull {return "/dev/nul"}sub case_tolerant {return 1}sub file_name_is_absolute {my ($self,$file)=@_;return scalar($file =~ m{^([a-z]:)?[\\/]}is)}sub path {my$path=$ENV{PATH};$path =~ s:\\:/:g;my@path=split(';',$path);for (@path){$_='.' if $_ eq ''}return@path}sub _cwd {return Cwd::sys_cwd()}my$tmpdir;sub tmpdir {return$tmpdir if defined$tmpdir;my@d=@ENV{qw(TMPDIR TEMP TMP)};$tmpdir=$_[0]->_tmpdir(@d,'/tmp','/')}sub catdir {my$self=shift;my@args=@_;for (@args){tr[\\][/];$_ .= "/" unless m{/$}}return$self->canonpath(join('',@args))}sub canonpath {my ($self,$path)=@_;return unless defined$path;$path =~ s/^([a-z]:)/\l$1/s;$path =~ s|\\|/|g;$path =~ s|([^/])/+|$1/|g;$path =~ s|(/\.)+/|/|g;$path =~ s|^(\./)+(?=[^/])||s;$path =~ s|/\Z(?!\n)|| unless$path =~ m#^([a-z]:)?/\Z(?!\n)#si;$path =~ s{^/\.\.$}{/};1 while$path =~ s{^/\.\.}{};return$path}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file)=('','','');if ($nofile){$path =~ m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;$volume=$1;$directory=$2}else {$path =~ m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;$volume=$1;$directory=$2;$file=$3}return ($volume,$directory,$file)}sub splitdir {my ($self,$directories)=@_ ;split m|[\\/]|,$directories,-1}sub catpath {my ($self,$volume,$directory,$file)=@_;$volume .= $1 if ($volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s && $directory =~ m@^[^\\/]@s);$volume .= $directory ;if ($volume !~ m@^[a-zA-Z]:\Z(?!\n)@s && $volume =~ m@[^\\/]\Z(?!\n)@ && $file =~ m@[^\\/]@){$volume =~ m@([\\/])@ ;my$sep=$1 ? $1 : '/' ;$volume .= $sep }$volume .= $file ;return$volume }sub abs2rel {my($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){$path=$self->rel2abs($path)}else {$path=$self->canonpath($path)}if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_volume,$path_directories,$path_file)=$self->splitpath($path,1);my ($base_volume,$base_directories)=$self->splitpath($base,1);return$path unless$path_volume eq $base_volume;my@pathchunks=$self->splitdir($path_directories);my@basechunks=$self->splitdir($base_directories);while (@pathchunks && @basechunks && lc($pathchunks[0])eq lc($basechunks[0])){shift@pathchunks ;shift@basechunks }$path_directories=CORE::join('/',@pathchunks);$base_directories=CORE::join('/',@basechunks);$base_directories =~ s|[^\\/]+|..|g ;if ($path_directories ne '' && $base_directories ne ''){$path_directories="$base_directories/$path_directories" }else {$path_directories="$base_directories$path_directories" }return$self->canonpath($self->catpath("",$path_directories,$path_file))}sub rel2abs {my ($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_directories,$path_file)=($self->splitpath($path,1))[1,2];my ($base_volume,$base_directories)=$self->splitpath($base,1);$path=$self->catpath($base_volume,$self->catdir($base_directories,$path_directories),$path_file)}return$self->canonpath($path)}1;
X86_64-LINUX_FILE_SPEC_OS2

$fatpacked{"x86_64-linux/File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_UNIX';
  package File::Spec::Unix;use strict;use vars qw($VERSION);$VERSION='3.40';$VERSION =~ tr/_//;sub canonpath {my ($self,$path)=@_;return unless defined$path;my$node='';my$double_slashes_special=$^O eq 'qnx' || $^O eq 'nto';if ($double_slashes_special && ($path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s)){$node=$1}$path =~ s|/{2,}|/|g;$path =~ s{(?:/\.)+(?:/|\z)}{/}g;$path =~ s|^(?:\./)+||s unless$path eq "./";$path =~ s|^/(?:\.\./)+|/|;$path =~ s|^/\.\.$|/|;$path =~ s|/\z|| unless$path eq "/";return "$node$path"}sub catdir {my$self=shift;$self->canonpath(join('/',@_,''))}sub catfile {my$self=shift;my$file=$self->canonpath(pop @_);return$file unless @_;my$dir=$self->catdir(@_);$dir .= "/" unless substr($dir,-1)eq "/";return$dir.$file}sub curdir {'.'}sub devnull {'/dev/null'}sub rootdir {'/'}my$tmpdir;sub _tmpdir {return$tmpdir if defined$tmpdir;my$self=shift;my@dirlist=@_;{no strict 'refs';if (${"\cTAINT"}){require Scalar::Util;@dirlist=grep {!Scalar::Util::tainted($_)}@dirlist}elsif ($] < 5.007){@dirlist=grep {eval {eval('1'.substr $_,0,0)}}@dirlist}}for (@dirlist){next unless defined && -d && -w _;$tmpdir=$_;last}$tmpdir=$self->curdir unless defined$tmpdir;$tmpdir=defined$tmpdir && $self->canonpath($tmpdir);return$tmpdir}sub tmpdir {return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir($ENV{TMPDIR},"/tmp")}sub updir {'..'}sub no_upwards {my$self=shift;return grep(!/^\.{1,2}\z/s,@_)}sub case_tolerant {0}sub file_name_is_absolute {my ($self,$file)=@_;return scalar($file =~ m:^/:s)}sub path {return ()unless exists$ENV{PATH};my@path=split(':',$ENV{PATH});for (@path){$_='.' if $_ eq ''}return@path}sub join {my$self=shift;return$self->catfile(@_)}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file)=('','','');if ($nofile){$directory=$path}else {$path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;$directory=$1;$file=$2}return ($volume,$directory,$file)}sub splitdir {return split m|/|,$_[1],-1}sub catpath {my ($self,$volume,$directory,$file)=@_;if ($directory ne '' && $file ne '' && substr($directory,-1)ne '/' && substr($file,0,1)ne '/'){$directory .= "/$file" }else {$directory .= $file }return$directory }sub abs2rel {my($self,$path,$base)=@_;$base=$self->_cwd()unless defined$base and length$base;($path,$base)=map$self->canonpath($_),$path,$base;my$path_directories;my$base_directories;if (grep$self->file_name_is_absolute($_),$path,$base){($path,$base)=map$self->rel2abs($_),$path,$base;my ($path_volume)=$self->splitpath($path,1);my ($base_volume)=$self->splitpath($base,1);return$path unless$path_volume eq $base_volume;$path_directories=($self->splitpath($path,1))[1];$base_directories=($self->splitpath($base,1))[1];if (!length($base_directories)and $self->file_name_is_absolute($base)){$base_directories=$self->rootdir}}else {my$wd=($self->splitpath($self->_cwd(),1))[1];$path_directories=$self->catdir($wd,$path);$base_directories=$self->catdir($wd,$base)}my@pathchunks=$self->splitdir($path_directories);my@basechunks=$self->splitdir($base_directories);if ($base_directories eq $self->rootdir){return$self->curdir if$path_directories eq $self->rootdir;shift@pathchunks;return$self->canonpath($self->catpath('',$self->catdir(@pathchunks),''))}my@common;while (@pathchunks && @basechunks && $self->_same($pathchunks[0],$basechunks[0])){push@common,shift@pathchunks ;shift@basechunks }return$self->curdir unless@pathchunks || @basechunks;my@reverse_base;while(defined(my$dir=shift@basechunks)){if($dir ne $self->updir){unshift@reverse_base,$self->updir;push@common,$dir}elsif(@common){if(@reverse_base && $reverse_base[0]eq $self->updir){shift@reverse_base;pop@common}else {unshift@reverse_base,pop@common}}}my$result_dirs=$self->catdir(@reverse_base,@pathchunks);return$self->canonpath($self->catpath('',$result_dirs,''))}sub _same {$_[1]eq $_[2]}sub rel2abs {my ($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}$path=$self->catdir($base,$path)}return$self->canonpath($path)}sub _cwd {require Cwd;Cwd::getcwd()}sub _collapse {my($fs,$path)=@_;my$updir=$fs->updir;my$curdir=$fs->curdir;my($vol,$dirs,$file)=$fs->splitpath($path);my@dirs=$fs->splitdir($dirs);pop@dirs if@dirs && $dirs[-1]eq '';my@collapsed;for my$dir (@dirs){if($dir eq $updir and @collapsed and length$collapsed[-1]and $collapsed[-1]ne $updir and $collapsed[-1]ne $curdir){pop@collapsed}else {push@collapsed,$dir}}return$fs->catpath($vol,$fs->catdir(@collapsed),$file)}1;
X86_64-LINUX_FILE_SPEC_UNIX

$fatpacked{"x86_64-linux/File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_VMS';
  package File::Spec::VMS;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);use File::Basename;use VMS::Filespec;my$use_feature;BEGIN {if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_feature=1}}sub _unix_rpt {my$unix_rpt;if ($use_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub canonpath {my($self,$path)=@_;return undef unless defined$path;my$unix_rpt=$self->_unix_rpt;if ($path =~ m|/|){my$pathify=$path =~ m|/\Z(?!\n)|;$path=$self->SUPER::canonpath($path);return$path if$unix_rpt;$path=$pathify ? vmspath($path): vmsify($path)}$path =~ s/(?<!\^)</[/;$path =~ s/(?<!\^)>/]/;$path =~ s/(?<!\^)\]\[\./\.\]\[/g;$path =~ s/(?<!\^)\[000000\.\]\[/\[/g;$path =~ s/(?<!\^)\[000000\./\[/g;$path =~ s/(?<!\^)\.\]\[000000\]/\]/g;$path =~ s/(?<!\^)\.\]\[/\./g;1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);1 while ($path =~ s/(?<!\^)([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);$path =~ s/(?<!\^)\[\.-/[-/;$path =~ s/(?<!\^)\.[^\]\.]+\.-\./\./g;$path =~ s/(?<!\^)\[[^\]\.]+\.-\./\[/g;$path =~ s/(?<!\^)\.[^\]\.]+\.-\]/\]/g;$path =~ s/(?<!\^)\[[^\]\.]+\.-\]/\[000000\]/g;$path =~ s/(?<!\^)\[\]// unless$path eq '[]';return$unix_rpt ? unixify($path): $path}sub catdir {my$self=shift;my$dir=pop;my$unix_rpt=$self->_unix_rpt;my@dirs=grep {defined()&& length()}@_;my$rslt;if (@dirs){my$path=(@dirs==1 ? $dirs[0]: $self->catdir(@dirs));my ($spath,$sdir)=($path,$dir);$spath =~ s/\.dir\Z(?!\n)//i;$sdir =~ s/\.dir\Z(?!\n)//i;if ($unix_rpt){$spath=unixify($spath)unless$spath =~ m#/#;$sdir=unixify($sdir)unless$sdir =~ m#/#;return$self->SUPER::catdir($spath,$sdir)}$sdir=$self->eliminate_macros($sdir)unless$sdir =~ /^[\w\-]+\Z(?!\n)/s;$rslt=$self->fixpath($self->eliminate_macros($spath)."/$sdir",1);if ($spath =~ /^[\[<][^.\-]/s){$rslt =~ s/^[^\[<]+//s}}else {if (not defined$dir or not length$dir){$rslt=''}else {$rslt=$unix_rpt ? $dir : vmspath($dir)}}return$self->canonpath($rslt)}sub catfile {my$self=shift;my$tfile=pop();my$file=$self->canonpath($tfile);my@files=grep {defined()&& length()}@_;my$unix_rpt=$self->_unix_rpt;my$rslt;if (@files){my$path=(@files==1 ? $files[0]: $self->catdir(@files));my$spath=$path;$spath =~ s/\.dir\Z(?!\n)//i;if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file)eq $file){$rslt="$spath$file"}else {$rslt=$self->eliminate_macros($spath);$rslt .= (defined($rslt)&& length($rslt)? '/' : '').unixify($file);$rslt=vmsify($rslt)unless$unix_rpt}}else {my$xfile=(defined($file)&& length($file))? $file : '';$rslt=$unix_rpt ? $file : vmsify($file)}return$self->canonpath($rslt)unless$unix_rpt;return$rslt}sub curdir {my$self=shift @_;return '.' if ($self->_unix_rpt);return '[]'}sub devnull {my$self=shift @_;return '/dev/null' if ($self->_unix_rpt);return "_NLA0:"}sub rootdir {my$self=shift @_;if ($self->_unix_rpt){my$try='/';my ($dev1,$ino1)=stat('/');my ($dev2,$ino2)=stat('.');if (($dev1!=$dev2)|| ($ino1!=$ino2)){return$try}return '/sys$disk/'}return 'SYS$DISK:[000000]'}my$tmpdir;sub tmpdir {my$self=shift @_;return$tmpdir if defined$tmpdir;if ($self->_unix_rpt){$tmpdir=$self->_tmpdir('/tmp','/sys$scratch',$ENV{TMPDIR});return$tmpdir}$tmpdir=$self->_tmpdir('sys$scratch:',$ENV{TMPDIR})}sub updir {my$self=shift @_;return '..' if ($self->_unix_rpt);return '[-]'}sub case_tolerant {return 1}sub path {my (@dirs,$dir,$i);while ($dir=$ENV{'DCL$PATH;' .$i++}){push(@dirs,$dir)}return@dirs}sub file_name_is_absolute {my ($self,$file)=@_;$file=$ENV{$file}while$file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};return scalar($file =~ m!^/!s || $file =~ m![<\[][^.\-\]>]! || $file =~ /:[^<\[]/)}sub splitpath {my($self,$path,$nofile)=@_;my($dev,$dir,$file)=('','','');my$vmsify_path=vmsify($path);if ($nofile){if($vmsify_path =~ /(.*)\](.+)/){$vmsify_path=$1.'.'.$2.']'}$vmsify_path =~ /(.+:)?(.*)/s;$dir=defined $2 ? $2 : '';return ($1 || '',$dir,$file)}else {$vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;return ($1 || '',$2 || '',$3)}}sub splitdir {my($self,$dirspec)=@_;my@dirs=();return@dirs if ((!defined$dirspec)|| ('' eq $dirspec));$dirspec =~ s/(?<!\^)</[/;$dirspec =~ s/(?<!\^)>/]/;$dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;$dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;$dirspec =~ s/(?<!\^)\[000000\./\[/g;$dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;$dirspec =~ s/(?<!\^)\.\]\[/\./g;while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g){}$dirspec="[$dirspec]" unless$dirspec =~ /(?<!\^)[\[<]/;$dirspec =~ s/^(\[|<)\./$1/;@dirs=split /(?<!\^)\./,vmspath($dirspec);$dirs[0]=~ s/^[\[<]//s;$dirs[-1]=~ s/[\]>]\Z(?!\n)//s;@dirs}sub catpath {my($self,$dev,$dir,$file)=@_;my ($dir_volume,$dir_dir,$dir_file)=$self->splitpath($dir);$dev=$dir_volume unless length$dev;$dir=length$dir_file ? $self->catfile($dir_dir,$dir_file): $dir_dir;if ($dev =~ m|^(?<!\^)/+([^/]+)|){$dev="$1:"}else {$dev .= ':' unless$dev eq '' or $dev =~ /:\Z(?!\n)/}if (length($dev)or length($dir)){$dir="[$dir]" unless$dir =~ /(?<!\^)[\[<\/]/;$dir=vmspath($dir)}$dir='' if length($dev)&& ($dir eq '[]' || $dir eq '<>');"$dev$dir$file"}sub abs2rel {my$self=shift;return vmspath(File::Spec::Unix::abs2rel($self,@_))if grep m{/},@_;my($path,$base)=@_;$base=$self->_cwd()unless defined$base and length$base;for ($path,$base){$_=$self->canonpath($_)}my ($path_volume,$path_directories,$path_file)=$self->splitpath($path);my ($base_volume,$base_directories,$base_file)=$self->splitpath($base);return$path unless lc($path_volume)eq lc($base_volume);for ($path,$base){$_=$self->rel2abs($_)}my@pathchunks=$self->splitdir($path_directories);my$pathchunks=@pathchunks;unshift(@pathchunks,'000000')unless$pathchunks[0]eq '000000';my@basechunks=$self->splitdir($base_directories);my$basechunks=@basechunks;unshift(@basechunks,'000000')unless$basechunks[0]eq '000000';while (@pathchunks && @basechunks && lc($pathchunks[0])eq lc($basechunks[0])){shift@pathchunks ;shift@basechunks }if ((@basechunks > 0)|| ($basechunks!=$pathchunks)){$path_directories=join '.',('-' x @basechunks,@pathchunks)}else {$path_directories=join '.',@pathchunks}$path_directories='['.$path_directories.']';return$self->canonpath($self->catpath('',$path_directories,$path_file))}sub rel2abs {my$self=shift ;my ($path,$base)=@_;return undef unless defined$path;if ($path =~ m/\//){$path=(-d $path || $path =~ m/\/\z/ ? vmspath($path): vmsify($path))}$base=vmspath($base)if defined$base && $base =~ m/\//;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_directories,$path_file)=($self->splitpath($path))[1,2];my ($base_volume,$base_directories)=$self->splitpath($base);$path_directories='' if$path_directories eq '[]' || $path_directories eq '<>';my$sep='' ;$sep='.' if ($base_directories =~ m{[^.\]>]\Z(?!\n)} && $path_directories =~ m{^[^.\[<]}s);$base_directories="$base_directories$sep$path_directories";$base_directories =~ s{\.?[\]>][\[<]\.?}{.};$path=$self->catpath($base_volume,$base_directories,$path_file)}return$self->canonpath($path)}sub eliminate_macros {my($self,$path)=@_;return '' unless (defined$path)&& ($path ne '');$self={}unless ref$self;if ($path =~ /\s/){return join ' ',map {$self->eliminate_macros($_)}split /\s+/,$path}my$npath=unixify($path);$npath =~ s{\0$}{};my($complex)=0;my($head,$macro,$tail);while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs){if (defined$self->{$2}){($head,$macro,$tail)=($1,$2,$3);if (ref$self->{$macro}){if (ref$self->{$macro}eq 'ARRAY'){$macro=join ' ',@{$self->{$macro}}}else {print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),"\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";$macro="\cB$macro\cB";$complex=1}}else {($macro=unixify($self->{$macro}))=~ s#/\Z(?!\n)##}$npath="$head$macro$tail"}}if ($complex){$npath =~ s#\cB(.*?)\cB#\${$1}#gs}$npath}sub fixpath {my($self,$path,$force_path)=@_;return '' unless$path;$self=bless {},$self unless ref$self;my($fixedpath,$prefix,$name);if ($path =~ /\s/){return join ' ',map {$self->fixpath($_,$force_path)}split /\s+/,$path}if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#){if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/){$fixedpath=vmspath($self->eliminate_macros($path))}else {$fixedpath=vmsify($self->eliminate_macros($path))}}elsif ((($prefix,$name)=($path =~ m#^\$\(([^\)]+)\)(.+)#s))&& $self->{$prefix}){my($vmspre)=$self->eliminate_macros("\$($prefix)");$vmspre=($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/)? vmspath($vmspre): '';$fixedpath=($vmspre ? $vmspre : $self->{$prefix}).$name;$fixedpath=vmspath($fixedpath)if$force_path}else {$fixedpath=$path;$fixedpath=vmspath($fixedpath)if$force_path}if (!defined($force_path)and $fixedpath !~ /[:>(.\]]/){$fixedpath=vmspath($fixedpath)if -d $fixedpath}$fixedpath =~ s/\.000000([\]>])/$1/;if ($path =~ /^[\[>][^.\-]/){$fixedpath =~ s/^[^\[<]+//}$fixedpath}1;
X86_64-LINUX_FILE_SPEC_VMS

$fatpacked{"x86_64-linux/File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_WIN32';
  package File::Spec::Win32;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);my$DRIVE_RX='[a-zA-Z]:';my$UNC_RX='(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';my$VOL_RX="(?:$DRIVE_RX|$UNC_RX)";sub devnull {return "nul"}sub rootdir {'\\'}my$tmpdir;sub tmpdir {return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir(map($ENV{$_},qw(TMPDIR TEMP TMP)),'SYS:/temp','C:\system\temp','C:/temp','/tmp','/')}sub case_tolerant {eval {require Win32API::File}or return 1;my$drive=shift || "C:";my$osFsType="\0"x256;my$osVolName="\0"x256;my$ouFsFlags=0;Win32API::File::GetVolumeInformation($drive,$osVolName,256,[],[],$ouFsFlags,$osFsType,256);if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()){return 0}else {return 1}}sub file_name_is_absolute {my ($self,$file)=@_;if ($file =~ m{^($VOL_RX)}o){my$vol=$1;return ($vol =~ m{^$UNC_RX}o ? 2 : $file =~ m{^$DRIVE_RX[\\/]}o ? 2 : 0)}return$file =~ m{^[\\/]} ? 1 : 0}sub catfile {shift;shift,return _canon_cat("/",@_)if $_[0]eq "";return _canon_cat(($_[0].'\\'),@_[1..$#_])if $_[0]=~ m{^$DRIVE_RX\z}o;return _canon_cat(@_)}sub catdir {shift;return "" unless @_;shift,return _canon_cat("/",@_)if $_[0]eq "";return _canon_cat(($_[0].'\\'),@_[1..$#_])if $_[0]=~ m{^$DRIVE_RX\z}o;return _canon_cat(@_)}sub path {my@path=split(';',$ENV{PATH});s/"//g for@path;@path=grep length,@path;unshift(@path,".");return@path}sub canonpath {return $_[1]if!defined($_[1])or $_[1]eq '';return _canon_cat($_[1])}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file)=('','','');if ($nofile){$path =~ m{^ ( $VOL_RX ? ) (.*) }sox;$volume=$1;$directory=$2}else {$path =~ m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;$volume=$1;$directory=$2;$file=$3}return ($volume,$directory,$file)}sub splitdir {my ($self,$directories)=@_ ;if ($directories !~ m|[\\/]\Z(?!\n)|){return split(m|[\\/]|,$directories)}else {my(@directories)=split(m|[\\/]|,"${directories}dummy");$directories[$#directories ]='' ;return@directories }}sub catpath {my ($self,$volume,$directory,$file)=@_;my$v;$volume .= $v if ((($v)=$volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s)&& $directory =~ m@^[^\\/]@s);$volume .= $directory ;if ($volume !~ m@^[a-zA-Z]:\Z(?!\n)@s && $volume =~ m@[^\\/]\Z(?!\n)@ && $file =~ m@[^\\/]@){$volume =~ m@([\\/])@ ;my$sep=$1 ? $1 : '\\' ;$volume .= $sep }$volume .= $file ;return$volume }sub _same {lc($_[1])eq lc($_[2])}sub rel2abs {my ($self,$path,$base)=@_;my$is_abs=$self->file_name_is_absolute($path);return$self->canonpath($path)if$is_abs==2;if ($is_abs){my$vol=($self->splitpath($self->_cwd()))[0];return$self->canonpath($vol .$path)}if (!defined($base)|| $base eq ''){require Cwd ;$base=Cwd::getdcwd(($self->splitpath($path))[0])if defined&Cwd::getdcwd ;$base=$self->_cwd()unless defined$base }elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_directories,$path_file)=($self->splitpath($path,1))[1,2];my ($base_volume,$base_directories)=$self->splitpath($base,1);$path=$self->catpath($base_volume,$self->catdir($base_directories,$path_directories),$path_file);return$self->canonpath($path)}sub _canon_cat {my ($first,@rest)=@_;my$volume=$first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x ? ucfirst($1).($2 ? "\\" : ""): $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs ? "\\\\$1".(defined $2 ? "\\$2" : "")."\\" : $first =~ s{ \A [\\/] }{}x ? "\\" : "";my$path=join "\\",$first,@rest;$path =~ tr#\\/#\\\\#s;$path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;$path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;while ($path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx){}$path =~ s#\A\\##;$path =~ s#\\\z##;if ($volume =~ m#\\\z#){$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;return $1 if$path eq "" and $volume =~ m#\A(\\\\.*)\\\z#s}return$path ne "" || $volume ? $volume.$path : "."}1;
X86_64-LINUX_FILE_SPEC_WIN32

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;

use App::cpanm::meta::checker;
my $app = App::cpanm::meta::checker->new_from_command;
$app->run_command();
exit 0;

